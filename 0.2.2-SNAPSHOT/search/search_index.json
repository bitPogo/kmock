{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KMock \u00b6 A humble mocking library for Kotlin, KotlinJS and Kotlin Multiplatform using Kotlin Symbol Processing (KSP). About The Project \u00b6 Writing mocks is certainly no witchcraft, but doing them by hand day for day can be dull. More importantly it takes time which can be better invested directly into writing tests. However, while JVM projects get indeed supreme support by either MockK or Mockito , Kotlin Multiplatform still has nothing comparable. KMock aims to fill that gap and will hopefully advance to there over time. Similar to other projects it uses KSP , but it is capable of associating generated Mocks correctly to their belonging shared source sets (like native, ios, etc) without additional setup and with minimal boilerplate done by consumers. KMock works currently only based on interfaces . It supports to some extent features like spying and relaxation of Mocks to make them non intrusive. So if the project caught your eye check out the Playground or dive into the Documentation . Dependencies \u00b6 KMock has the following dependencies: AndroidGradlePlugin (AGP) 7.2.1 Kotlin 1.6.21 AtomicFu 0.17.3 Touchlab's Stately 1.2.1 Square KotlinPoet 1.11.0 Kotlin Symbol Processing (KSP) 1.6.21-1.0.6 Gradle 7.4.2 Additional Requirements \u00b6 Android 6.0 (API 21) to Android 12 (API 31) Java 11 Changelog \u00b6 See changelog . Versioning \u00b6 This project uses Semantic Versioning as a guideline for our versioning. Contributing \u00b6 You want to help or share a proposal? You have a specific problem? Read the following: Code of Conduct for details on our code of conduct. Contribution Guide for details about how to report bugs and propose features. Releasing \u00b6 Please take a look here . Copyright and License \u00b6 Copyright \u00a9 2022 Matthias Geisler / All rights reserved. Please refer to the License for further details.","title":"Home"},{"location":"#kmock","text":"A humble mocking library for Kotlin, KotlinJS and Kotlin Multiplatform using Kotlin Symbol Processing (KSP).","title":"KMock"},{"location":"#about-the-project","text":"Writing mocks is certainly no witchcraft, but doing them by hand day for day can be dull. More importantly it takes time which can be better invested directly into writing tests. However, while JVM projects get indeed supreme support by either MockK or Mockito , Kotlin Multiplatform still has nothing comparable. KMock aims to fill that gap and will hopefully advance to there over time. Similar to other projects it uses KSP , but it is capable of associating generated Mocks correctly to their belonging shared source sets (like native, ios, etc) without additional setup and with minimal boilerplate done by consumers. KMock works currently only based on interfaces . It supports to some extent features like spying and relaxation of Mocks to make them non intrusive. So if the project caught your eye check out the Playground or dive into the Documentation .","title":"About The Project"},{"location":"#dependencies","text":"KMock has the following dependencies: AndroidGradlePlugin (AGP) 7.2.1 Kotlin 1.6.21 AtomicFu 0.17.3 Touchlab's Stately 1.2.1 Square KotlinPoet 1.11.0 Kotlin Symbol Processing (KSP) 1.6.21-1.0.6 Gradle 7.4.2","title":"Dependencies"},{"location":"#additional-requirements","text":"Android 6.0 (API 21) to Android 12 (API 31) Java 11","title":"Additional Requirements"},{"location":"#changelog","text":"See changelog .","title":"Changelog"},{"location":"#versioning","text":"This project uses Semantic Versioning as a guideline for our versioning.","title":"Versioning"},{"location":"#contributing","text":"You want to help or share a proposal? You have a specific problem? Read the following: Code of Conduct for details on our code of conduct. Contribution Guide for details about how to report bugs and propose features.","title":"Contributing"},{"location":"#releasing","text":"Please take a look here .","title":"Releasing"},{"location":"#copyright-and-license","text":"Copyright \u00a9 2022 Matthias Geisler / All rights reserved. Please refer to the License for further details.","title":"Copyright and License"},{"location":"changelog/","text":"Changelog \u00b6 All important changes of this project must be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 Changed \u00b6 Deprecated \u00b6 Removed \u00b6 Fixed \u00b6 Security \u00b6 Bumped \u00b6 0.3.0-rc01 \u00b6 Added \u00b6 preventResolvingOfAliases as workaround for AccessMethods with expect/actual Aliases which cause incremental builds to fail Bumped \u00b6 Kotlin 1.6.10 -> 1.6.21 AtomicFu 0.17.1 -> 0.17.3 KSP 1.6.10-1.0.4 -> 1.6.21-1.0.6 0.2.2 \u00b6 Fixed \u00b6 run / runs does not trigger SideEffect invocation 0.2.1 \u00b6 Fixed \u00b6 Plugin triggered the usage of the legacy JS compiler for KotlinJs 0.2.0 \u00b6 Added \u00b6 and ArgumentConstraint getValue which preserves the old behaviour of get (PropertyProxy) getValues to replace getMany (PropertyProxy) error to replace throws (FunProxy) errors to replace throwsMany (FunProxy) returns which acts as setter for getValue / returnValue for Proxies returnsMany which acts as setter for getValues / returnValues for Proxies throws (infix method) which acts as setter for error for FunProxies throwsMany (infix method) which acts as setter for errors for FunProxies runOnGet which acts as setter for getSideEffect for PropertyProxies runOnSet which acts as setter for setSideEffect for PropertyProxies hasNoFurtherInvocations to ease assertProxy Changed \u00b6 The plugin can now applied directly while configuration must be done after the kotlin setup AccessMethods need always a hint if the Template has type parameters ProxyNameResolver is capable of utilizing the actual types of generic parameters when overloaded run / runs are now infix methods Proxies have now an operator for get which means they can be accessed like Arrays BREAKING get is now responsible for the SideEffect of PropertyProxies Deprecated \u00b6 getMany (PropertyProxy) throws (FunProxy) throwsMany (FunProxy) Removed \u00b6 BREAKING getSideEffect (PropertyProxy) Fixed \u00b6 vararg eats specialised Array Types (e.g. IntArray) and covariant types when inherited Factories for Multi-Interface-Mocks Multi-Boundary Parameter are not right resolved when mixed multi with regular parameter in nested types Collisions of type aliases with regular method signatures 0.2.0-rc01 \u00b6 Added \u00b6 or ArgumentConstraint not ArgumentConstraint spiesOnly in the Gradle extension, in order to tell the processor to only create kspy . Also spyOn is not needed in this configuration spyAll in the Gradle extension, in order to tell the processor to create for al given interfaces also a spy entryPoint vararg is now supported by Mocks freezeOnDefault in the Gradle extension, which sets a default freeze value for kspy and kmock useTypePrefixFor for overloaded names in order to ease them and avoid collisions customMethodNames in order to allow complete custom names for methods allowInterfaces , which combines allowInterfacesOnKmock and allowInterfacesOnKspy disableFactories in order to disable the generation of kmock and kspy if needed customAnnotationsForMeta to provide a hook for the usage of customized annotation for meta/shared sources assertOrder in order to make the names more consistent and preserves the old behaviour of verifyStrictOrder assertProxy as alternative to verify iosSimulatorArm64 support Support for instrumented Android tests (aka androidAndroidTest) on KMP Multi-Interface Mocks support Interface receiver members are full supported run for FunProxies to mitigate the strict assignment policy in terms of a single SideEffect runs for FunProxies to mitigate the strict assignment policy in terms of SideEffects throwsMany for FunProxies to align the the FunProxy API enableFineGrainedNames in order to allow fine grained typing (experimental/not this will feature helps you only in a non JVM context) KMock experimental annotation, which is agnostic in terms of source sets KMockMulti experimental annotation, which is agnostic in terms of source sets Changed \u00b6 Generated mocks don't contain runtime logic any longer Mutable properties of Proxies now separate froze/unfrozen state is cleaner to improve Runtime kmock and kspy are using now a shared function to improve compile time Non intrusive behaviour (spy & relaxation) is now resolved by proxy invocation rather then by proxy initialisation in order to cover edge cases Assertion-/VerificationChain is not coupled any longer directly to proxies and provide improved error messages Expectation Methods do not bleed into the global context any longer verifyStrictOrder is now used for total order of certain Proxies but allows partial order between different Proxies Android MinSDK 23 -> 21 spyOn is now capable of picking up KMock defined Aliases kspy in terms of generics not longer exposed if not declared via spyOn or spiesOnly Relaxation method gets now the return type boundaries delegated, if generic in order to resolve type conflicts Generic methods names get prefixed by the generic type name, if it is overloaded to avoid name collisions Generic methods names get prefixed by an indicator, if it is overloaded and nullable to avoid name collisions Meta/Shared Source Annotation are now supporting platform references (e.g. instead of metaTest you can write meta) Custom Source Annotation are now supporting platform references (e.g. instead of sharedTest you can write shared) Proxy-Access-Methods and their corresponding verification/assertion counter parts verifer argument is now called collector in kmock and kspy Removed \u00b6 allowedRecursiveTypes , since it is no longer needed due to the new spy invocation allowInterfacesOnKmock , use allowInterfaces instead allowInterfacesOnKspy , use allowInterfaces instead Old experimental ProxyAssertion family, use assertProxy or verify instead uselessPrefixes in the Gradle Extension Fixed \u00b6 FunProxy names with nullable or multi-bounded types defined as generic parameter Annotation was not picked up when more then one Annotation was used Factories for Common were not created when no Template was specified Parallel declared shared source were eaten up by each other Nested Generic Types were not resolved for Proxies Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable Bumped \u00b6 KotlinPoet 1.10.2 -> 1.11.0 Gradle 7.4.1 -> 7.4.2 Android Gradle Plugin 7.1.2 -> 7.2.1 0.1.1 \u00b6 Fixed \u00b6 Warnings for unused expression and unused parameter in MockFactory Bumped \u00b6 Gradle 7.2 -> 7.4.1 0.1.0 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All important changes of this project must be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"","title":"Added"},{"location":"changelog/#changed","text":"","title":"Changed"},{"location":"changelog/#deprecated","text":"","title":"Deprecated"},{"location":"changelog/#removed","text":"","title":"Removed"},{"location":"changelog/#fixed","text":"","title":"Fixed"},{"location":"changelog/#security","text":"","title":"Security"},{"location":"changelog/#bumped","text":"","title":"Bumped"},{"location":"changelog/#030-rc01","text":"","title":"0.3.0-rc01"},{"location":"changelog/#added_1","text":"preventResolvingOfAliases as workaround for AccessMethods with expect/actual Aliases which cause incremental builds to fail","title":"Added"},{"location":"changelog/#bumped_1","text":"Kotlin 1.6.10 -> 1.6.21 AtomicFu 0.17.1 -> 0.17.3 KSP 1.6.10-1.0.4 -> 1.6.21-1.0.6","title":"Bumped"},{"location":"changelog/#022","text":"","title":"0.2.2"},{"location":"changelog/#fixed_1","text":"run / runs does not trigger SideEffect invocation","title":"Fixed"},{"location":"changelog/#021","text":"","title":"0.2.1"},{"location":"changelog/#fixed_2","text":"Plugin triggered the usage of the legacy JS compiler for KotlinJs","title":"Fixed"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#added_2","text":"and ArgumentConstraint getValue which preserves the old behaviour of get (PropertyProxy) getValues to replace getMany (PropertyProxy) error to replace throws (FunProxy) errors to replace throwsMany (FunProxy) returns which acts as setter for getValue / returnValue for Proxies returnsMany which acts as setter for getValues / returnValues for Proxies throws (infix method) which acts as setter for error for FunProxies throwsMany (infix method) which acts as setter for errors for FunProxies runOnGet which acts as setter for getSideEffect for PropertyProxies runOnSet which acts as setter for setSideEffect for PropertyProxies hasNoFurtherInvocations to ease assertProxy","title":"Added"},{"location":"changelog/#changed_1","text":"The plugin can now applied directly while configuration must be done after the kotlin setup AccessMethods need always a hint if the Template has type parameters ProxyNameResolver is capable of utilizing the actual types of generic parameters when overloaded run / runs are now infix methods Proxies have now an operator for get which means they can be accessed like Arrays BREAKING get is now responsible for the SideEffect of PropertyProxies","title":"Changed"},{"location":"changelog/#deprecated_1","text":"getMany (PropertyProxy) throws (FunProxy) throwsMany (FunProxy)","title":"Deprecated"},{"location":"changelog/#removed_1","text":"BREAKING getSideEffect (PropertyProxy)","title":"Removed"},{"location":"changelog/#fixed_3","text":"vararg eats specialised Array Types (e.g. IntArray) and covariant types when inherited Factories for Multi-Interface-Mocks Multi-Boundary Parameter are not right resolved when mixed multi with regular parameter in nested types Collisions of type aliases with regular method signatures","title":"Fixed"},{"location":"changelog/#020-rc01","text":"","title":"0.2.0-rc01"},{"location":"changelog/#added_3","text":"or ArgumentConstraint not ArgumentConstraint spiesOnly in the Gradle extension, in order to tell the processor to only create kspy . Also spyOn is not needed in this configuration spyAll in the Gradle extension, in order to tell the processor to create for al given interfaces also a spy entryPoint vararg is now supported by Mocks freezeOnDefault in the Gradle extension, which sets a default freeze value for kspy and kmock useTypePrefixFor for overloaded names in order to ease them and avoid collisions customMethodNames in order to allow complete custom names for methods allowInterfaces , which combines allowInterfacesOnKmock and allowInterfacesOnKspy disableFactories in order to disable the generation of kmock and kspy if needed customAnnotationsForMeta to provide a hook for the usage of customized annotation for meta/shared sources assertOrder in order to make the names more consistent and preserves the old behaviour of verifyStrictOrder assertProxy as alternative to verify iosSimulatorArm64 support Support for instrumented Android tests (aka androidAndroidTest) on KMP Multi-Interface Mocks support Interface receiver members are full supported run for FunProxies to mitigate the strict assignment policy in terms of a single SideEffect runs for FunProxies to mitigate the strict assignment policy in terms of SideEffects throwsMany for FunProxies to align the the FunProxy API enableFineGrainedNames in order to allow fine grained typing (experimental/not this will feature helps you only in a non JVM context) KMock experimental annotation, which is agnostic in terms of source sets KMockMulti experimental annotation, which is agnostic in terms of source sets","title":"Added"},{"location":"changelog/#changed_2","text":"Generated mocks don't contain runtime logic any longer Mutable properties of Proxies now separate froze/unfrozen state is cleaner to improve Runtime kmock and kspy are using now a shared function to improve compile time Non intrusive behaviour (spy & relaxation) is now resolved by proxy invocation rather then by proxy initialisation in order to cover edge cases Assertion-/VerificationChain is not coupled any longer directly to proxies and provide improved error messages Expectation Methods do not bleed into the global context any longer verifyStrictOrder is now used for total order of certain Proxies but allows partial order between different Proxies Android MinSDK 23 -> 21 spyOn is now capable of picking up KMock defined Aliases kspy in terms of generics not longer exposed if not declared via spyOn or spiesOnly Relaxation method gets now the return type boundaries delegated, if generic in order to resolve type conflicts Generic methods names get prefixed by the generic type name, if it is overloaded to avoid name collisions Generic methods names get prefixed by an indicator, if it is overloaded and nullable to avoid name collisions Meta/Shared Source Annotation are now supporting platform references (e.g. instead of metaTest you can write meta) Custom Source Annotation are now supporting platform references (e.g. instead of sharedTest you can write shared) Proxy-Access-Methods and their corresponding verification/assertion counter parts verifer argument is now called collector in kmock and kspy","title":"Changed"},{"location":"changelog/#removed_2","text":"allowedRecursiveTypes , since it is no longer needed due to the new spy invocation allowInterfacesOnKmock , use allowInterfaces instead allowInterfacesOnKspy , use allowInterfaces instead Old experimental ProxyAssertion family, use assertProxy or verify instead uselessPrefixes in the Gradle Extension","title":"Removed"},{"location":"changelog/#fixed_4","text":"FunProxy names with nullable or multi-bounded types defined as generic parameter Annotation was not picked up when more then one Annotation was used Factories for Common were not created when no Template was specified Parallel declared shared source were eaten up by each other Nested Generic Types were not resolved for Proxies Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable","title":"Fixed"},{"location":"changelog/#bumped_2","text":"KotlinPoet 1.10.2 -> 1.11.0 Gradle 7.4.1 -> 7.4.2 Android Gradle Plugin 7.1.2 -> 7.2.1","title":"Bumped"},{"location":"changelog/#011","text":"","title":"0.1.1"},{"location":"changelog/#fixed_5","text":"Warnings for unused expression and unused parameter in MockFactory","title":"Fixed"},{"location":"changelog/#bumped_3","text":"Gradle 7.2 -> 7.4.1","title":"Bumped"},{"location":"changelog/#010","text":"Initial release.","title":"0.1.0"},{"location":"concept/","text":"Concept \u00b6 Writing mocks is no witchcraft, but doing them by hand day for day can be dull. While KMP has come to stay it still lacks a mock library which can deal well with KMPs language features satisfactorily. Well complaining is easy and \"how hard can it\"\u2122 be to create such a library? Hence, KMock was born. Approach \u00b6 As other existing KMP mock libraries, KMock utilizes the power of Kotlin Symbol Processing (KSP) and generates mocks based on interfaces. Well, actually, in a strict sense, KMock generates stubs or fakes to a certain degree. It draws its biggest inspiration from Python\u2019s MagicMock in terms of the API, since it is easy to work with and offers conceptually a way to deal with the nature of KMP. While some mocking libraries depend on record-replay-verify pattern, KMock does not. It's mind model blends more into the arrange-act-assert pattern (AAA) . For example while you write in mockk: @Test fun sampleTest () { // arrange val someInstance : SomeInterface = mockk () // record every { someInstance . someProperty } returns \"any\" every { someInstance . someMethod ( any (), any ()) } returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () // assert verify ( exactly = 1 ) { someInstance . someProperty } verify ( exactly = 1 ) { someInstance . someMethod ( any (), any ()) } } You'll write in KMock: @Test fun sampleTest () { // arrange val someInstance : SomeInterfaceMock = kmock () someInstance . _someProperty . getValue = \"any\" someInstance . _someMethod . returnValue = \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () // assert assertProxy { someInstance . _someProperty . wasGotten () someInstance . _someMethod . hasBeenCalledWith ( any (), any ()) } } In fact KMock will proxy each public member of a given interface instead of proxy the entire interface at once. This also allows for less intrusive behaviour than traditional mocking libraries. A second noteworthy side effect due to this approach is that most functionality is directly bound to the generated Mocks, so things will just pop up in your IDE or Editor. This hopefully flattens the learning curve too. Lastly it allows to minimize any ambiguity in terms of overloading or eases the work with receivers, which are runtime based libraries mostly struggle with. Another ingredient of KMock is that the library should do the heavy lifting as much as possible. This means a consumer should not have to engage in complicated configuration to make it work with KMP. Ideally it should just work, while supporting different tests and code styles. Therefore KMock implements a basic support for Relaxation or Spying. Also most features operate on demand and can be turned on/off. But each luck has its price\u2026 Trade Offs \u00b6 While it so far it all sounds appealing, KMock of course has its conceptual trade offs. First and foremost compile time - while other libraries will try to resolve mostly everything at runtime, KMock will distribute things between compile- and runtime. This naturally means compiling will need more time, even if we speak about seconds here. Even though KMock is not optimized yet, it will most likely never be completely able to go toe to toe with pure runtime libraries. But you pay for accuracy and convenience. Also direct proxy access is not robust against refactoring since the generated names are detached from the interface it is based on. This goes especially for overloaded names and it bring its own batch of ugliness. While this a major drawback, KMock has experimental features to address these issues. Even though they are not completely matured yet and cannot be used for all use cases, they hopefully tackle these problems. What is the overall goal? \u00b6 Aside from the roadmap, KMock 's main aim is to make your life easier as much as possible. It will offer at some point in the future a proof of concept how implementation can be mocked, while it most likely never makes it into the main branch.","title":"Concept"},{"location":"concept/#concept","text":"Writing mocks is no witchcraft, but doing them by hand day for day can be dull. While KMP has come to stay it still lacks a mock library which can deal well with KMPs language features satisfactorily. Well complaining is easy and \"how hard can it\"\u2122 be to create such a library? Hence, KMock was born.","title":"Concept"},{"location":"concept/#approach","text":"As other existing KMP mock libraries, KMock utilizes the power of Kotlin Symbol Processing (KSP) and generates mocks based on interfaces. Well, actually, in a strict sense, KMock generates stubs or fakes to a certain degree. It draws its biggest inspiration from Python\u2019s MagicMock in terms of the API, since it is easy to work with and offers conceptually a way to deal with the nature of KMP. While some mocking libraries depend on record-replay-verify pattern, KMock does not. It's mind model blends more into the arrange-act-assert pattern (AAA) . For example while you write in mockk: @Test fun sampleTest () { // arrange val someInstance : SomeInterface = mockk () // record every { someInstance . someProperty } returns \"any\" every { someInstance . someMethod ( any (), any ()) } returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () // assert verify ( exactly = 1 ) { someInstance . someProperty } verify ( exactly = 1 ) { someInstance . someMethod ( any (), any ()) } } You'll write in KMock: @Test fun sampleTest () { // arrange val someInstance : SomeInterfaceMock = kmock () someInstance . _someProperty . getValue = \"any\" someInstance . _someMethod . returnValue = \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () // assert assertProxy { someInstance . _someProperty . wasGotten () someInstance . _someMethod . hasBeenCalledWith ( any (), any ()) } } In fact KMock will proxy each public member of a given interface instead of proxy the entire interface at once. This also allows for less intrusive behaviour than traditional mocking libraries. A second noteworthy side effect due to this approach is that most functionality is directly bound to the generated Mocks, so things will just pop up in your IDE or Editor. This hopefully flattens the learning curve too. Lastly it allows to minimize any ambiguity in terms of overloading or eases the work with receivers, which are runtime based libraries mostly struggle with. Another ingredient of KMock is that the library should do the heavy lifting as much as possible. This means a consumer should not have to engage in complicated configuration to make it work with KMP. Ideally it should just work, while supporting different tests and code styles. Therefore KMock implements a basic support for Relaxation or Spying. Also most features operate on demand and can be turned on/off. But each luck has its price\u2026","title":"Approach"},{"location":"concept/#trade-offs","text":"While it so far it all sounds appealing, KMock of course has its conceptual trade offs. First and foremost compile time - while other libraries will try to resolve mostly everything at runtime, KMock will distribute things between compile- and runtime. This naturally means compiling will need more time, even if we speak about seconds here. Even though KMock is not optimized yet, it will most likely never be completely able to go toe to toe with pure runtime libraries. But you pay for accuracy and convenience. Also direct proxy access is not robust against refactoring since the generated names are detached from the interface it is based on. This goes especially for overloaded names and it bring its own batch of ugliness. While this a major drawback, KMock has experimental features to address these issues. Even though they are not completely matured yet and cannot be used for all use cases, they hopefully tackle these problems.","title":"Trade Offs"},{"location":"concept/#what-is-the-overall-goal","text":"Aside from the roadmap, KMock 's main aim is to make your life easier as much as possible. It will offer at some point in the future a proof of concept how implementation can be mocked, while it most likely never makes it into the main branch.","title":"What is the overall goal?"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"migration/","text":"Migration Guide \u00b6 Apologies! Something was broken to improve KMock. But don't panic! 0.2.0-rc01 to 0.2.0 \u00b6 Behaviour Changes \u00b6 The get property of PropertyProxy is now responsible for the SideEffect. This was done to get a more coherent API for this proxy type. getValue takes over for get to hold simple values. Removed \u00b6 Replace getSideEffect with get . 0.1.1 to 0.2.0-rc01 \u00b6 API changes \u00b6 Names \u00b6 FunProxy names with nullable or Multi-Bounded types defined as generic parameter - this may break some Proxies if they are referring to overloaded methods. Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable - this may break some Proxies if they are referring to overloaded methods. The verifier argument of factories is now called collector . NonfreezingVerifier is now NonFreezingVerifier . verifyStrictOrder is now assertOrder . Removed \u00b6 allowedRecursiveTypes - this option is obsolete and would have no effect. allowInterfacesOnKmock - this option is obsolete and would lead to undesired behaviour, but you can use allowInterfaces instead. allowInterfacesOnKspy - this option is obsolete and would lead to undesired behaviour, but you can use allowInterfaces instead. The experimental ProxyAssertion family - those methods were only aliases for verify(exacty = 1) { ... } . Please consider assertProxy or verify instead. uselessPrefixes in the Gradle Extension - this option is obsolete and would have no effect. Changed \u00b6 Expectation Methods do not bleed into the global context any longer. This means the imports of the old extensions must be removed and it they will work again. Behaviour Changes \u00b6 verifyStrictOrder is now used for total order of certain Proxies but allows partial order between different Proxies, use assertOrder instead.","title":"Migration Guide"},{"location":"migration/#migration-guide","text":"Apologies! Something was broken to improve KMock. But don't panic!","title":"Migration Guide"},{"location":"migration/#020-rc01-to-020","text":"","title":"0.2.0-rc01 to 0.2.0"},{"location":"migration/#behaviour-changes","text":"The get property of PropertyProxy is now responsible for the SideEffect. This was done to get a more coherent API for this proxy type. getValue takes over for get to hold simple values.","title":"Behaviour Changes"},{"location":"migration/#removed","text":"Replace getSideEffect with get .","title":"Removed"},{"location":"migration/#011-to-020-rc01","text":"","title":"0.1.1 to 0.2.0-rc01"},{"location":"migration/#api-changes","text":"","title":"API changes"},{"location":"migration/#names","text":"FunProxy names with nullable or Multi-Bounded types defined as generic parameter - this may break some Proxies if they are referring to overloaded methods. Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable - this may break some Proxies if they are referring to overloaded methods. The verifier argument of factories is now called collector . NonfreezingVerifier is now NonFreezingVerifier . verifyStrictOrder is now assertOrder .","title":"Names"},{"location":"migration/#removed_1","text":"allowedRecursiveTypes - this option is obsolete and would have no effect. allowInterfacesOnKmock - this option is obsolete and would lead to undesired behaviour, but you can use allowInterfaces instead. allowInterfacesOnKspy - this option is obsolete and would lead to undesired behaviour, but you can use allowInterfaces instead. The experimental ProxyAssertion family - those methods were only aliases for verify(exacty = 1) { ... } . Please consider assertProxy or verify instead. uselessPrefixes in the Gradle Extension - this option is obsolete and would have no effect.","title":"Removed"},{"location":"migration/#changed","text":"Expectation Methods do not bleed into the global context any longer. This means the imports of the old extensions must be removed and it they will work again.","title":"Changed"},{"location":"migration/#behaviour-changes_1","text":"verifyStrictOrder is now used for total order of certain Proxies but allows partial order between different Proxies, use assertOrder instead.","title":"Behaviour Changes"},{"location":"quickstart/","text":"Quickstart \u00b6 Install \u00b6 In your buildSrc/build.gradle.kts: repositories { ... mavenCentral () } dependencies { implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } In your root project build.gradle.kts: allprojects { ... repositories { ... mavenCentral () } } Setup \u00b6 import tech.antibytes.gradle.kmock.KMockExtension ... plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... sourceSets { ... val commonTest by getting { dependencies { ... implementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } } ... } ... } kmock { rootPackage = \"my.root.package\" } Generate a Mock \u00b6 import tech.antibytes.kmock.MockCommon @MockCommon ( SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... } Use your Mocks \u00b6 ... @Test fun sampleTest () { // arrange val someInstance : OtherSampleInterfaceMock = kmock () someInstance . _fetch . returnValue = Any () someInstance . _find returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } ... Verify/Assert \u00b6 @Test fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . verifOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } }","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#install","text":"In your buildSrc/build.gradle.kts: repositories { ... mavenCentral () } dependencies { implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } In your root project build.gradle.kts: allprojects { ... repositories { ... mavenCentral () } }","title":"Install"},{"location":"quickstart/#setup","text":"import tech.antibytes.gradle.kmock.KMockExtension ... plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... sourceSets { ... val commonTest by getting { dependencies { ... implementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } } ... } ... } kmock { rootPackage = \"my.root.package\" }","title":"Setup"},{"location":"quickstart/#generate-a-mock","text":"import tech.antibytes.kmock.MockCommon @MockCommon ( SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... }","title":"Generate a Mock"},{"location":"quickstart/#use-your-mocks","text":"... @Test fun sampleTest () { // arrange val someInstance : OtherSampleInterfaceMock = kmock () someInstance . _fetch . returnValue = Any () someInstance . _find returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } ...","title":"Use your Mocks"},{"location":"quickstart/#verifyassert","text":"@Test fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . verifOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } }","title":"Verify/Assert"},{"location":"roadmap/","text":"Roadmap \u00b6 0.3.0 \u00b6 optimize & stabilize proxy access methods stabilize agnostic annotations improve support for Android prototype class mocking for JVM based sources sets support more platforms 0.2.0 \u00b6 stabilize of the mock generation in respect of base use-cases \u2705\ufe0f support varargs \u2705\ufe0f support receivers \u2705\ufe0f support custom annotations \u2705\ufe0f support mocks based on multiple interfaces \u2705\ufe0f stabilize verification/assertion \u2705\ufe0f stabilize proxy api \u2705\ufe0f introduce a more robust way to access proxies \u2705\ufe0f prototype an agnostic annotation for arbitrary sources \u2705\ufe0f publish to MavenCentral \u2705\ufe0f 0.1.0 \u00b6 support hierarchical source sets \u2705 support properties \u2705 support methods \u2705 support overloading \u2705 support generics \u2705 support spies \u2705 support relaxation \u2705 support verification \u2705 support verification over multiple proxies \u2705 prototype assertion \u2705","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#030","text":"optimize & stabilize proxy access methods stabilize agnostic annotations improve support for Android prototype class mocking for JVM based sources sets support more platforms","title":"0.3.0"},{"location":"roadmap/#020","text":"stabilize of the mock generation in respect of base use-cases \u2705\ufe0f support varargs \u2705\ufe0f support receivers \u2705\ufe0f support custom annotations \u2705\ufe0f support mocks based on multiple interfaces \u2705\ufe0f stabilize verification/assertion \u2705\ufe0f stabilize proxy api \u2705\ufe0f introduce a more robust way to access proxies \u2705\ufe0f prototype an agnostic annotation for arbitrary sources \u2705\ufe0f publish to MavenCentral \u2705\ufe0f","title":"0.2.0"},{"location":"roadmap/#010","text":"support hierarchical source sets \u2705 support properties \u2705 support methods \u2705 support overloading \u2705 support generics \u2705 support spies \u2705 support relaxation \u2705 support verification \u2705 support verification over multiple proxies \u2705 prototype assertion \u2705","title":"0.1.0"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Versions currently being supported with security updates: Version Supported latest Reporting a Vulnerability \u00b6 Please use an Issue to report vulnerabilities. If security bug is discovered, following actions will be taken: Confirm the problem and determine the affected versions. Audit code to find any potential similar problems. Prepare fixes for all releases still under maintenance.","title":"Security Policy"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Versions currently being supported with security updates: Version Supported latest","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Please use an Issue to report vulnerabilities. If security bug is discovered, following actions will be taken: Confirm the problem and determine the affected versions. Audit code to find any potential similar problems. Prepare fixes for all releases still under maintenance.","title":"Reporting a Vulnerability"},{"location":"development/badges/","text":"Create a badge \u00b6 The badges are generate with Shields.io to generate our Badges. Use the following links in order to document or update any used badge and place the resulting SVG files the projects assets/images folder. Badges \u00b6 Latest release curl \"https://img.shields.io/badge/Release-0.3.0--rc01-blueviolet.svg?style=flat\" -s -o badge-release-latest.svg Platforms curl \"https://img.shields.io/badge/Platform-Android%20\u2022%20JVM%20\u2022%20Js%20\u2022%20iOS%20\u2022%20LinuxX64%20-blue.svg\" -s -o badge-release-latest.svg License curl \"https://img.shields.io/badge/license-Apache_2.0-blue.svg\" -s -o badge-license.svg License \u00b6 Shields is licensed under Creative Commons Zero v1.0 Universal (as of 2022-02-23)","title":"Badges"},{"location":"development/badges/#create-a-badge","text":"The badges are generate with Shields.io to generate our Badges. Use the following links in order to document or update any used badge and place the resulting SVG files the projects assets/images folder.","title":"Create a badge"},{"location":"development/badges/#badges","text":"Latest release curl \"https://img.shields.io/badge/Release-0.3.0--rc01-blueviolet.svg?style=flat\" -s -o badge-release-latest.svg Platforms curl \"https://img.shields.io/badge/Platform-Android%20\u2022%20JVM%20\u2022%20Js%20\u2022%20iOS%20\u2022%20LinuxX64%20-blue.svg\" -s -o badge-release-latest.svg License curl \"https://img.shields.io/badge/license-Apache_2.0-blue.svg\" -s -o badge-license.svg","title":"Badges"},{"location":"development/badges/#license","text":"Shields is licensed under Creative Commons Zero v1.0 Universal (as of 2022-02-23)","title":"License"},{"location":"development/code-of-conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body, size, disability, ethnicity, class, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior should be reported. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here .","title":"Code of Conduct"},{"location":"development/code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"development/code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body, size, disability, ethnicity, class, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"development/code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"development/code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"development/code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"development/code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior should be reported. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"development/code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here .","title":"Attribution"},{"location":"development/contributing/","text":"Contributing \u00b6 When contributing to this project, this document should help you get started. Code Of Conduct \u00b6 This project adheres to the Contributor Covenant Code Of Conduct . By participating, you are expected to uphold this code. Issues \u00b6 GitHub issues are the way to track bugs and enhancements. Issues are hold in high regards in this project, so please feel free to open issue for: Questions to help to improve the user experience Ideas which are a great source for contributions Problems show where this project is lacking or not working as expected. If you are reporting a problem, please provide as much information as possible, since this will help us to fix it. This includes, if possible, a description or small sample project how to reproduce the problem. Also please check out first if an issue had been already opened with your request. Contribute Code \u00b6 Development Process \u00b6 Prerequisites \u00b6 Android Studio 2021.2.1 Patch 1 or later Java 11 Kotlin 1.6.10 Gradle 7.4.2 Features \u00b6 Every change has to branch of from main and use this branch naming convention: feature/{type_of_change}-{short_description} main must be always in releasable state. Type Of Change \u00b6 add for new features or functionality change for changes in existing features or functionality deprecated for features which are at their end of life and will be removed in the future remove for removed features or functionality fix for any bug fixes bump for dependency updates security in case of vulnerabilities Examples: feature/add-awesome-hashing-algorithm feature/remove-not-so-awesome-algorithm feature/fix-algorithm-corner-case feature/bump-lib-to-1.3.0 Pull Request \u00b6 Pull requests are always welcome! If you (going to) contribute, please make sure you made clear which problem you are attempt solve or what is nature of your improvement. Create Pull Request \u00b6 Please use our title pattern: {type of change} {short description} : type of change can be: Add for new features or functionality, Change for changes in existing features or functionality, Deprecated for features which are at their end of life and will be removed in the future, Remove for removed features or functionality, Fix for any bug fixes, Security in case of vulnerabilities, Bump for dependency updates, followed by a short description of your change. Example: Add awesome hashing algorithm Changed thumbnail generation Pull requests must fill the provided template. Put N/A when a paragraph cannot be filled. Labels should be used (enhancement,bugfix, help wanted etc...) to categorise your contribution. Important : Work in progress pull-requests should be created as a draft. Code Review \u00b6 Your contribution has to meet these criteria: Functional and fitting in the project Code style and naming conventions followed Test written and passing Existing Tests still passing Continuous Integration build passing Cross platform testing done for all supported platforms Documentation updated (if necessary) Changelog updated (if necessary) Dependencies using other licenses \u00b6 Contributing code and introducing dependencies into the repository from other projects that use one of the following licenses is allowed. MIT ISC Apache 2.0 Any other contribution needs to be signed off by the project owners.","title":"Contributing"},{"location":"development/contributing/#contributing","text":"When contributing to this project, this document should help you get started.","title":"Contributing"},{"location":"development/contributing/#code-of-conduct","text":"This project adheres to the Contributor Covenant Code Of Conduct . By participating, you are expected to uphold this code.","title":"Code Of Conduct"},{"location":"development/contributing/#issues","text":"GitHub issues are the way to track bugs and enhancements. Issues are hold in high regards in this project, so please feel free to open issue for: Questions to help to improve the user experience Ideas which are a great source for contributions Problems show where this project is lacking or not working as expected. If you are reporting a problem, please provide as much information as possible, since this will help us to fix it. This includes, if possible, a description or small sample project how to reproduce the problem. Also please check out first if an issue had been already opened with your request.","title":"Issues"},{"location":"development/contributing/#contribute-code","text":"","title":"Contribute Code"},{"location":"development/contributing/#development-process","text":"","title":"Development Process"},{"location":"development/contributing/#prerequisites","text":"Android Studio 2021.2.1 Patch 1 or later Java 11 Kotlin 1.6.10 Gradle 7.4.2","title":"Prerequisites"},{"location":"development/contributing/#features","text":"Every change has to branch of from main and use this branch naming convention: feature/{type_of_change}-{short_description} main must be always in releasable state.","title":"Features"},{"location":"development/contributing/#type-of-change","text":"add for new features or functionality change for changes in existing features or functionality deprecated for features which are at their end of life and will be removed in the future remove for removed features or functionality fix for any bug fixes bump for dependency updates security in case of vulnerabilities Examples: feature/add-awesome-hashing-algorithm feature/remove-not-so-awesome-algorithm feature/fix-algorithm-corner-case feature/bump-lib-to-1.3.0","title":"Type Of Change"},{"location":"development/contributing/#pull-request","text":"Pull requests are always welcome! If you (going to) contribute, please make sure you made clear which problem you are attempt solve or what is nature of your improvement.","title":"Pull Request"},{"location":"development/contributing/#create-pull-request","text":"Please use our title pattern: {type of change} {short description} : type of change can be: Add for new features or functionality, Change for changes in existing features or functionality, Deprecated for features which are at their end of life and will be removed in the future, Remove for removed features or functionality, Fix for any bug fixes, Security in case of vulnerabilities, Bump for dependency updates, followed by a short description of your change. Example: Add awesome hashing algorithm Changed thumbnail generation Pull requests must fill the provided template. Put N/A when a paragraph cannot be filled. Labels should be used (enhancement,bugfix, help wanted etc...) to categorise your contribution. Important : Work in progress pull-requests should be created as a draft.","title":"Create Pull Request"},{"location":"development/contributing/#code-review","text":"Your contribution has to meet these criteria: Functional and fitting in the project Code style and naming conventions followed Test written and passing Existing Tests still passing Continuous Integration build passing Cross platform testing done for all supported platforms Documentation updated (if necessary) Changelog updated (if necessary)","title":"Code Review"},{"location":"development/contributing/#dependencies-using-other-licenses","text":"Contributing code and introducing dependencies into the repository from other projects that use one of the following licenses is allowed. MIT ISC Apache 2.0 Any other contribution needs to be signed off by the project owners.","title":"Dependencies using other licenses"},{"location":"development/releasing/","text":"Releasing \u00b6 Releases are automatically created from added tags using GitHub Actions. A tag needs to be in the form of v{major}.{minor}.{patch} . Release preparation \u00b6 Create a release branch of from main branch with this pattern: release/{major}.{minor}/prepare-{major}.{minor}.{patch} Update changelog.md by creating a new Unreleased section and change current unreleased to release version Update the latest release badge Release \u00b6 For a release, this project uses GitHub releases: Create a new release Set the tag Set the title Add a description in form of a changelog Publish when ready","title":"Releasing"},{"location":"development/releasing/#releasing","text":"Releases are automatically created from added tags using GitHub Actions. A tag needs to be in the form of v{major}.{minor}.{patch} .","title":"Releasing"},{"location":"development/releasing/#release-preparation","text":"Create a release branch of from main branch with this pattern: release/{major}.{minor}/prepare-{major}.{minor}.{patch} Update changelog.md by creating a new Unreleased section and change current unreleased to release version Update the latest release badge","title":"Release preparation"},{"location":"development/releasing/#release","text":"For a release, this project uses GitHub releases: Create a new release Set the tag Set the title Add a description in form of a changelog Publish when ready","title":"Release"},{"location":"howto/advanced/","text":"Advanced Concepts \u00b6 Spying \u00b6 KMock supports Spying to a certain degree. While you still need to instantiate the subject to spy on (SO) by hand, you can delegate the SO to kspy and voila habemus spy! However Spying is disabled by default and is selective. To enable it please take a look at the Configuration of the Gradle Plugin . Once it is enabled KMock will generate an additional factory kspy . kspy works similar to kmock and takes 3 arguments spyOn , collect and freeze . spyOn expects the SO and you need to reference the Mock Class. @Test fun sampleTest () { // arrange val subjectToSpyOn = AnyImplementation () val someInstance : SomeInterfaceMock = kspy ( spyOn = subjectToSpyOn ) ... } Also as with kmock , if the Template is generic you have to delegate an additional argument templateType which must be the KClass of the Template the Spy is referring to. Spies for MultiMocks will always treated like they are generic. This means you have to delegate all template types the multi mock is referring to: @Test fun sampleTest () { // arrange val subjectToSpyOn = AnyMultiImplementation () val someInstance : SomeInterfaceMock = kspy ( spyOn = subjectToSpyOn , templateType0 = CharSequence :: class , templateType1 = Comparable :: class , ) ... } You still can override specific methods or properties by using the corresponding Proxy Property. In other words methods or properties of an SO are used instead of throwing an error, if no behaviour or stub was assigned to a Proxy, so it acts completely non intrusive. Note Setters are always invoked. Special behaviour of Spies \u00b6 In terms of Spies there is one big difference you need to be aware of. Since Build-In methods like equals are delegated to the SO as well it might result in a behaviour which is not obvious right away: @Test fun sampleTest () { val subjectToSpyOn = AnyImplementation () val someInstance : SomeInterfaceMock = kspy ( subjectToSpyOn ) assertTrue (( someInstance as Any ) == someInstance ) // will pass assertTrue (( someInstance as Any ) == subjectToSpyOn ) // will pass assertTrue (( subjectToSpyOn as Any ) == someInstance ) // will fail } While the first and second Assertion passes the last won't. Why is it that? KMock uses inheritance not reflection as you remember. The last assertion fails since AnyImplementation has no custom implementation of equals and uses the default one. If AnyImplementation makes a custom comparison while taking only properties into account, the Assertion may pass. Relaxing \u00b6 KMock also facilitates Relaxation to a certain degree and will hopefully get better in it over time. However it requires boilerplate code done by you. The Relaxation of methods which return Unit is Build-In feature, so do not worry about it. You only need to switch relaxUnitFun to true and be done with it. Similar things apply for Build-In methods, if they are enabled. They will fallback to their parents Build-In methods if no return value is set for them. To get full Relaxation support you need to implement a Relaxer function and annotate it properly: @Relaxer internal inline fun < reified T > relax ( id : String ): T { ... } The Annotation @Relaxer tells KMock that a Relaxer is present and is up for usage. The Relaxer can be an arbitrary function but has to follow a specific signature, similar as shown above. The function can be either inline or not. The type parameter can be either reified or not, but must be present and used as the return value. There can be only one type parameter. The function can be marked as internal or not, but must be visible by the Mocks. Also the function must take exactly one argument, which is a String. This argument will be provided when invoked by a Proxy and is its id. You may use it to differentiate between Proxies. At last you need to switch relaxing on by adding relaxed = true to kmock . However since this sounds cumbersome you may want to use it together with KFixture . Well, in certain cases the type parameter will not work as return value - Generics. If KMock encounters Generics as return values of a method/property it adds additional arguments ( type$Idx ) to invocation of the Relaxer Function For example: relax ( proxyId , type0 = Any :: class , type1 = Comparable :: class , ) This means KMock expects you to provide a proper definition of fun relax(proxyId: String, type0: KClass<Any>, type1: KClass<Comparable<Any>>): Any . The amount of type arguments depends on the boundaries of the generic return type. For example <T> fun method(): T where T: Any, T: Comparable<Any> will resolved to the invocation above. Memory Model \u00b6 KMock still uses Kotlin's \u2018old\u2019 Memory Model. Therefore you might run into some trouble in certain cases. Both factory functions - kmock and kspy - take an argument freeze which is true by default. This means everything which is delegated to an Proxy (including Relaxation) or Verifier must conform with the freezing Memory Model of Kotlin. By switching freeze to false it changes the flavour to non-freezing. If you use non freezing Mocks, make sure you use the corresponding Asserter/Verifier ( NonFreezingVerifier / NonFreezingAsserter ) and all interacting Mocks are non-freezing as well. This is inconvenient for now but will go away once the new Memory Model is more stable. Customization \u00b6 ArgumentConstraints \u00b6 KMock is capable of using your custom defined ArgumentConstraints. You can simply extend ArgumentConstraint of the KMockContract and implement the functionality you require and use it. Done! Verification \u00b6 While nearly all Assertion/Verification methods are not able to extended, you are still able to customize verify due to the power of extension function for either the Proxy , FunProxy , PropertyProxy , SyncFunProxy or AsyncFunProxy Interface of the KMockContract . KMock exposes 4 functions which are intended for this purpose. getArgumentsByType , getAllArgumentsByType and getAllArgumentsBoxedByType working only for FunProxies, while getArgumentsForCall works for all Proxy types. getArgumentsByType can be used to retrieve Arguments for a specific call and type, getAllArgumentsByType and getAllArgumentsBoxedByType collecting over all invocations. The main difference between the latter methods is simply that getAllArgumentsByType will collect arguments in a linear order, while getAllArgumentsBoxedByType will box them in a List per call. Use those methods with caution, since they are likely subject to changes, once the concept of assertions gets a second look. KMock itself uses getArgumentsForCall which you might wanna use as well while working with PropertyProxies or you need a type unaware method to extract arguments from Proxies. Happy coding!","title":"Advanced Concepts"},{"location":"howto/advanced/#advanced-concepts","text":"","title":"Advanced Concepts"},{"location":"howto/advanced/#spying","text":"KMock supports Spying to a certain degree. While you still need to instantiate the subject to spy on (SO) by hand, you can delegate the SO to kspy and voila habemus spy! However Spying is disabled by default and is selective. To enable it please take a look at the Configuration of the Gradle Plugin . Once it is enabled KMock will generate an additional factory kspy . kspy works similar to kmock and takes 3 arguments spyOn , collect and freeze . spyOn expects the SO and you need to reference the Mock Class. @Test fun sampleTest () { // arrange val subjectToSpyOn = AnyImplementation () val someInstance : SomeInterfaceMock = kspy ( spyOn = subjectToSpyOn ) ... } Also as with kmock , if the Template is generic you have to delegate an additional argument templateType which must be the KClass of the Template the Spy is referring to. Spies for MultiMocks will always treated like they are generic. This means you have to delegate all template types the multi mock is referring to: @Test fun sampleTest () { // arrange val subjectToSpyOn = AnyMultiImplementation () val someInstance : SomeInterfaceMock = kspy ( spyOn = subjectToSpyOn , templateType0 = CharSequence :: class , templateType1 = Comparable :: class , ) ... } You still can override specific methods or properties by using the corresponding Proxy Property. In other words methods or properties of an SO are used instead of throwing an error, if no behaviour or stub was assigned to a Proxy, so it acts completely non intrusive. Note Setters are always invoked.","title":"Spying"},{"location":"howto/advanced/#special-behaviour-of-spies","text":"In terms of Spies there is one big difference you need to be aware of. Since Build-In methods like equals are delegated to the SO as well it might result in a behaviour which is not obvious right away: @Test fun sampleTest () { val subjectToSpyOn = AnyImplementation () val someInstance : SomeInterfaceMock = kspy ( subjectToSpyOn ) assertTrue (( someInstance as Any ) == someInstance ) // will pass assertTrue (( someInstance as Any ) == subjectToSpyOn ) // will pass assertTrue (( subjectToSpyOn as Any ) == someInstance ) // will fail } While the first and second Assertion passes the last won't. Why is it that? KMock uses inheritance not reflection as you remember. The last assertion fails since AnyImplementation has no custom implementation of equals and uses the default one. If AnyImplementation makes a custom comparison while taking only properties into account, the Assertion may pass.","title":"Special behaviour of Spies"},{"location":"howto/advanced/#relaxing","text":"KMock also facilitates Relaxation to a certain degree and will hopefully get better in it over time. However it requires boilerplate code done by you. The Relaxation of methods which return Unit is Build-In feature, so do not worry about it. You only need to switch relaxUnitFun to true and be done with it. Similar things apply for Build-In methods, if they are enabled. They will fallback to their parents Build-In methods if no return value is set for them. To get full Relaxation support you need to implement a Relaxer function and annotate it properly: @Relaxer internal inline fun < reified T > relax ( id : String ): T { ... } The Annotation @Relaxer tells KMock that a Relaxer is present and is up for usage. The Relaxer can be an arbitrary function but has to follow a specific signature, similar as shown above. The function can be either inline or not. The type parameter can be either reified or not, but must be present and used as the return value. There can be only one type parameter. The function can be marked as internal or not, but must be visible by the Mocks. Also the function must take exactly one argument, which is a String. This argument will be provided when invoked by a Proxy and is its id. You may use it to differentiate between Proxies. At last you need to switch relaxing on by adding relaxed = true to kmock . However since this sounds cumbersome you may want to use it together with KFixture . Well, in certain cases the type parameter will not work as return value - Generics. If KMock encounters Generics as return values of a method/property it adds additional arguments ( type$Idx ) to invocation of the Relaxer Function For example: relax ( proxyId , type0 = Any :: class , type1 = Comparable :: class , ) This means KMock expects you to provide a proper definition of fun relax(proxyId: String, type0: KClass<Any>, type1: KClass<Comparable<Any>>): Any . The amount of type arguments depends on the boundaries of the generic return type. For example <T> fun method(): T where T: Any, T: Comparable<Any> will resolved to the invocation above.","title":"Relaxing"},{"location":"howto/advanced/#memory-model","text":"KMock still uses Kotlin's \u2018old\u2019 Memory Model. Therefore you might run into some trouble in certain cases. Both factory functions - kmock and kspy - take an argument freeze which is true by default. This means everything which is delegated to an Proxy (including Relaxation) or Verifier must conform with the freezing Memory Model of Kotlin. By switching freeze to false it changes the flavour to non-freezing. If you use non freezing Mocks, make sure you use the corresponding Asserter/Verifier ( NonFreezingVerifier / NonFreezingAsserter ) and all interacting Mocks are non-freezing as well. This is inconvenient for now but will go away once the new Memory Model is more stable.","title":"Memory Model"},{"location":"howto/advanced/#customization","text":"","title":"Customization"},{"location":"howto/advanced/#argumentconstraints","text":"KMock is capable of using your custom defined ArgumentConstraints. You can simply extend ArgumentConstraint of the KMockContract and implement the functionality you require and use it. Done!","title":"ArgumentConstraints"},{"location":"howto/advanced/#verification","text":"While nearly all Assertion/Verification methods are not able to extended, you are still able to customize verify due to the power of extension function for either the Proxy , FunProxy , PropertyProxy , SyncFunProxy or AsyncFunProxy Interface of the KMockContract . KMock exposes 4 functions which are intended for this purpose. getArgumentsByType , getAllArgumentsByType and getAllArgumentsBoxedByType working only for FunProxies, while getArgumentsForCall works for all Proxy types. getArgumentsByType can be used to retrieve Arguments for a specific call and type, getAllArgumentsByType and getAllArgumentsBoxedByType collecting over all invocations. The main difference between the latter methods is simply that getAllArgumentsByType will collect arguments in a linear order, while getAllArgumentsBoxedByType will box them in a List per call. Use those methods with caution, since they are likely subject to changes, once the concept of assertions gets a second look. KMock itself uses getArgumentsForCall which you might wanna use as well while working with PropertyProxies or you need a type unaware method to extract arguments from Proxies. Happy coding!","title":"Verification"},{"location":"howto/annotations/","text":"Declaring a Mock \u00b6 To declare Mocks you have to use KMock's annotations or those you have declared in the KMock's Gradle Extension. You can declare Mocks in a central place (per platform) or per test suite. However declaring them in a central place is discouraged since it violates the DAMP unit tests principle. Build-In Annotations \u00b6 KMock offers you 6 annotations which are considered as stable to declare a Mock: Mock/MultiMock for Platform specific Mocks, MockShared/MultiMockShared for Shared Sources (like native), MockCommon/MultiMockCommon for commonTest. Single Interface Mocks \u00b6 Declaring a Mock for common or platforms works alike. Mock/MockCommon takes an arbitrary amount of interfaces which will used as Templates to generate Mocks of: import tech.antibytes.kmock.MockCommon @MockCommon ( SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... } MockShared takes an additional argument sourceSetName in order to associate the Templates with the Shared Source Set like iosTest . You can also use only a short reference instead of the full name (e.g. long: iosTest , short: ios ): import tech.antibytes.kmock.MockShared @MockShared ( \"native\" , SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... } Tip You do not have to mix those Annotations per test set. KMock is totally fine if you declare a Template in one source as common and in another source as platform source. It will resolve any conflicts according to their precedence in Kotlin's hierarchical source sets. As a rule of thumb - you need for Single Interface Mocks one Annotation per test set. Multi Interface Mocks \u00b6 KMock is also capable of generate Mocks based on multiple interfaces. Similar to Single Interface Mocks, MultiMock and MultiMockCommon can declare Mocks in the very similar way: import tech.antibytes.kmock.MultiMockCommon @MultiMockCommon ( \"MergedCommon\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... } In difference to Single Interface Mocks, Multi Interface Mocks Annotations can be applied multiple times per test set. Also all Multi Interface Mocks Annotations need an additional argument name which will be used as name for the generated Mock. All referenced Interfaces will then be merged into one Mock. As with Single Interface Mocks, the Annotation for Shared Sources needs an additional argument sourceSetName to bind the generated Mock to a source set: import tech.antibytes.kmock.MultiMockShared @MultiMockShared ( sourceSetName = \"nativeTest\" , name = \"MergedShared\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... } Warning Do not use this feature to create one Mock for all tests. It was never intended for that. Note Even if it is not directly intended you can use Multi-Interface Annotations to produce Aliases for Single-Interface Mocks. Custom Annotations \u00b6 You can also use your custom Annotations in order to ease the handling with Shared Sources. Your Annotations are not allowed to reference common and have to take a arbitrary amount of KClass (aka vararg) for Single Interface Mocks. For Multi Interface Mocks your Annotations have to take as the very first argument a String additionally to the KClasses: package my.package @Retention ( AnnotationRetention . SOURCE ) @Target ( AnnotationTarget . CLASS ) @MustBeDocumented annotation class Custom ( vararg val interfaces : KClass <*> ) @Repeatable @Retention ( AnnotationRetention . SOURCE ) @Target ( AnnotationTarget . CLASS ) @MustBeDocumented annotation class MultiCustom ( val name : String , vararg val interfaces : KClass <*> ) Experimental Annotations \u00b6 With 0.2.0 KMock offers 2 new experimental Annotations - KMock and KMockMulti which lift the need of telling KMock to which Source Set a Mock binds. Those Annotations will determine the Source Set of a Mock based on the contexts they are declared. However those Annotations are considers as experimental since there might be edge cases which are not covered by them. They can be used in the exact same way as Mock or MockMulti : import tech.antibytes.kmock.MultiMockShared @KMock ( SampleInterface :: class , OtherSampleInterface :: class , ... ) @KMockMulti ( name = \"MergedShared\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... }","title":"Declaring a Mock"},{"location":"howto/annotations/#declaring-a-mock","text":"To declare Mocks you have to use KMock's annotations or those you have declared in the KMock's Gradle Extension. You can declare Mocks in a central place (per platform) or per test suite. However declaring them in a central place is discouraged since it violates the DAMP unit tests principle.","title":"Declaring a Mock"},{"location":"howto/annotations/#build-in-annotations","text":"KMock offers you 6 annotations which are considered as stable to declare a Mock: Mock/MultiMock for Platform specific Mocks, MockShared/MultiMockShared for Shared Sources (like native), MockCommon/MultiMockCommon for commonTest.","title":"Build-In Annotations"},{"location":"howto/annotations/#single-interface-mocks","text":"Declaring a Mock for common or platforms works alike. Mock/MockCommon takes an arbitrary amount of interfaces which will used as Templates to generate Mocks of: import tech.antibytes.kmock.MockCommon @MockCommon ( SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... } MockShared takes an additional argument sourceSetName in order to associate the Templates with the Shared Source Set like iosTest . You can also use only a short reference instead of the full name (e.g. long: iosTest , short: ios ): import tech.antibytes.kmock.MockShared @MockShared ( \"native\" , SampleInterface :: class , OtherSampleInterface :: class , ... ) class SampleTestSet { ... } Tip You do not have to mix those Annotations per test set. KMock is totally fine if you declare a Template in one source as common and in another source as platform source. It will resolve any conflicts according to their precedence in Kotlin's hierarchical source sets. As a rule of thumb - you need for Single Interface Mocks one Annotation per test set.","title":"Single Interface Mocks"},{"location":"howto/annotations/#multi-interface-mocks","text":"KMock is also capable of generate Mocks based on multiple interfaces. Similar to Single Interface Mocks, MultiMock and MultiMockCommon can declare Mocks in the very similar way: import tech.antibytes.kmock.MultiMockCommon @MultiMockCommon ( \"MergedCommon\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... } In difference to Single Interface Mocks, Multi Interface Mocks Annotations can be applied multiple times per test set. Also all Multi Interface Mocks Annotations need an additional argument name which will be used as name for the generated Mock. All referenced Interfaces will then be merged into one Mock. As with Single Interface Mocks, the Annotation for Shared Sources needs an additional argument sourceSetName to bind the generated Mock to a source set: import tech.antibytes.kmock.MultiMockShared @MultiMockShared ( sourceSetName = \"nativeTest\" , name = \"MergedShared\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... } Warning Do not use this feature to create one Mock for all tests. It was never intended for that. Note Even if it is not directly intended you can use Multi-Interface Annotations to produce Aliases for Single-Interface Mocks.","title":"Multi Interface Mocks"},{"location":"howto/annotations/#custom-annotations","text":"You can also use your custom Annotations in order to ease the handling with Shared Sources. Your Annotations are not allowed to reference common and have to take a arbitrary amount of KClass (aka vararg) for Single Interface Mocks. For Multi Interface Mocks your Annotations have to take as the very first argument a String additionally to the KClasses: package my.package @Retention ( AnnotationRetention . SOURCE ) @Target ( AnnotationTarget . CLASS ) @MustBeDocumented annotation class Custom ( vararg val interfaces : KClass <*> ) @Repeatable @Retention ( AnnotationRetention . SOURCE ) @Target ( AnnotationTarget . CLASS ) @MustBeDocumented annotation class MultiCustom ( val name : String , vararg val interfaces : KClass <*> )","title":"Custom Annotations"},{"location":"howto/annotations/#experimental-annotations","text":"With 0.2.0 KMock offers 2 new experimental Annotations - KMock and KMockMulti which lift the need of telling KMock to which Source Set a Mock binds. Those Annotations will determine the Source Set of a Mock based on the contexts they are declared. However those Annotations are considers as experimental since there might be edge cases which are not covered by them. They can be used in the exact same way as Mock or MockMulti : import tech.antibytes.kmock.MultiMockShared @KMock ( SampleInterface :: class , OtherSampleInterface :: class , ... ) @KMockMulti ( name = \"MergedShared\" , SampleDomainObject :: class , ExampleContract . DecoderFactory :: class ) class SampleTestSet { ... }","title":"Experimental Annotations"},{"location":"howto/assertion/","text":"Assertion and Verification \u00b6 As other libraries KMock offers a way to assert or verify invocations of Proxies (not Mocks!). Expectations Method \u00b6 Assertion and Verification share the same API - Expectation Methods. While those methods will behave similarly in both contexts, they have different nuances. @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () ... // assert verify ( exactly = 1 ) { someInstance . _fetch . hasBeenCalledWith ( \"someUrl\" ) } assertProxy { someInstance . _find . hasBeenCalledWith ( \"something\" ) } } hasBeenCalledWith for example is such a Expectation Method. Other Expectation Method for FunProxies are: Method What it does hasBeenCalled determines if the Proxy was invoked. hasBeenCalledWithVoid determines if the Proxy was invoked without any arguments. hasBeenCalledWith determines if the Proxy was invoked with the given arguments. The arguments must follow the order of the Templates arguments but can contain gaps and do not need exhaustive. hasBeenStrictlyCalledWith determines if the Proxy was invoked with the given arguments. The arguments must follow the order of the Template arguments strictly and must provide all arguments in their order. hasBeenCalledWithout determines if the Proxy was invoked without the given arguments. PropertyProxies have their own specialized set of Expectation Methods: Method What it does wasGotten determines if the Proxy was invoked as a getter. wasSet determines if the Proxy was invoked as a setter. wasSetTo determines if the Proxy was invoked as a setter with the given argument. Argument Constraints \u00b6 While it might not always be desirable to assert/verify against an concrete value, KMock also offers ArgumentConstraints. For example if you simply want to confirm that a Proxy was called with a certain type you may do the following: @Test fun sampleTest () { val someInstance : SampleRemoteRepositoryMock = kmock () ... verify ( exactly = 1 ) { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) } } Internally all concrete types will be converted into an eq constraint. For example an Expectation Method is called with 42 . 42 will be converted into eq(42) . Currently the following constraints are implemented: ArgumentConstraint What it does and which allows to chain multiple values or constraints together with an logical and. any matches always (including null). If a concrete type was given it matches only if a recorded argument fulfils the expected type (exclusive null). eq matches if the recorded argument is equal to the expected argument. isNot matches if the recorded argument is not equal to the expected argument. isSame matches if the recorded argument is identical as the expected argument. isNotSame matches if the recorded argument is not identical as the expected argument. not matches if the negated outcome of a given ArgumentConstraint matches. or which allows to chain multiple values or constraints together with a logical or. Single Proxy Assertion/Verification \u00b6 As you might now already seen KMock offers for Single Proxy Assertion/Verification verify and assertProxy . So what is now exactly the difference and what has that to do with the Expectation Methods? Well, verify will look if any invocation of the Proxy will match the given Expectation. assertProxy will go through the invocation from the first to latest. In short verify can skip invocations while assertProxy cannot. Also both functions are not capable to be used in order to make statements about the interactions between Proxies. However you can use assertProxy with multiple Proxies: @Test fun sampleTest () { val someInstance : SampleRemoteRepositoryMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) } verify ( atLeast = 1 ) { someInstance . _find . hasBeenCalledWith ( any ( String :: class )) } assertProxy { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) someInstance . _find . hasBeenCalledWith ( any ( String :: class )) } } As shown above you can and assuming fetch has been called 2x and with that _fetch was invoked 2x. Also assuming find was invoked, verify and assertProxy will pass. However you cannot say if fetch was called before or after find . Assuming now fetch has been called only once, verify will still pass, while assertProxy will fail. Since verify is less strict about the order it checks if a Proxy was invoked exactly , atLeast or atMost certain times. assertProxy on the other hand will always tell what is wrong with current and where but will only cover those invocation you told it cover. In order to ensure you covered all invocations via assertProxy you can use hasNoFurtherInvocations . Tip As a rule of thumb - if you want to cover a Proxy which is invoked multiple times you should consider using verify. If you cover a proxy which is invoked only once you should consider assertProxy . Note You need only one assertProxy per test case, strictly speaking. In terms of verify you need one per Verification. Experimental Operators \u00b6 Due to the special nature of verify KMock offers a additional way to make verify more versatile and expressive - Operators: Consider following source: interface SampleThing { fun method ( arg0 : String , arg1 : Int , arg2 : Any ) } Now you can use Operators with verify like : @Test fun sampleTest () { // arrange val someInstance : SampleThingMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _find . method ( \"payload\" , 23 , \"any\" ) or someInstance . _find . method ( \"payload\" , 42 , \"notAny\" ) } } Instead of: @Test fun sampleTest () { // arrange val someInstance : SampleThingMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _find . method ( \"payload\" , or ( eq ( 23 ), eq ( 42 )), or ( eq ( \"any\" ), eq ( \"notAny\" ))) } } These Operators are still experimental but will become stable soon. Other Operators are: Operator What it does union resolves the union of 2 Expectations. or is an alias of union . intersection resolves the intersection of 2 Expectations. and is an alias of intersection . diff resolves the symmetrical difference of 2 Expectations. xor is an alias of diff Multi Proxy Assertion/Verification \u00b6 To keep track of interaction between Proxies KMock offers also a way. You'll need to inject a Asserter/Verifier into the Mocks when they are initialized via the collector argument of kmock or kspy . Note Asserter and Verifier are the same. In fact Verifier is a type alias of Asserter. Import Make sure you use the fitting type of Asserter/Verifier according to the Memory Model . fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . assertOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } } KMock offers 3 flavours to deal with interaction of multiple Proxies - assertOrder , verifyStrictOrder and verifyOrder . assertOrder is super strict - you must cover all invocations of all collected Proxies in order and exhaustively. verifyStrictOrder is less strict - it allows you to skip an arbitrary number of invocations of Proxies, but once you started to verify them it acts like assertOrder . verifyOrder is even less strict but also less descriptive in terms of errors - it allows you to skip an arbitrary invocations of Proxies and will only care about the relative order of Proxies. All 3 flavours use the same API as verify/assertProxy to determine if a invocation is valid or not. For example: fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . verifOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } } To make the difference more clear: * assertOrder will fail if the invocation will not exactly in the order someProperty - someMethod - someMethod and there are more than these invocations. * verifyStrictOrder will fail if the invocation will not exactly in the order someProperty - someMethod - someMethod but it will not care if any invocation happens before that chain. * verifyOrder will fail if the invocation is not in the relative order someProperty - someMethod - someMethod but it will not care if any invocation happens before, after or in between them. Optionally you can use ensureVerificationOf if you need any insurance that all Proxies have been covered during a run by a Verifier/Asserter. Verifier/Asserter can additionally be initialised with the coverAllInvocations flag, which is false by default. This flag forces Proxies, which are excluded from Verification/Assertion by default to be covered during a test run. This is only important if you have to cover build-in methods like equals , since they are excluded from Verification via Verifier/Asserter by default due to their special nature. Teardown \u00b6 As with Mocks Verifier/Asserter have a clear method, which opens them up for reuse. So do not forget to call it. Compatibility with Proxy Access Methods \u00b6 In case you use Proxy Access Methods with Coroutines (aka asyncProxyOf ) you may have to use the corresponding Verification/Assertion methods. They act the very same way as they synchronous counter parts. The only difference is that they start with the prefix async like asyncVerify . Important Do not use them with direct Proxy Access together - their soul purpose is bound to asyncProxyOf and asyncProxyOf only.","title":"Assertion/Verification"},{"location":"howto/assertion/#assertion-and-verification","text":"As other libraries KMock offers a way to assert or verify invocations of Proxies (not Mocks!).","title":"Assertion and Verification"},{"location":"howto/assertion/#expectations-method","text":"Assertion and Verification share the same API - Expectation Methods. While those methods will behave similarly in both contexts, they have different nuances. @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () ... // assert verify ( exactly = 1 ) { someInstance . _fetch . hasBeenCalledWith ( \"someUrl\" ) } assertProxy { someInstance . _find . hasBeenCalledWith ( \"something\" ) } } hasBeenCalledWith for example is such a Expectation Method. Other Expectation Method for FunProxies are: Method What it does hasBeenCalled determines if the Proxy was invoked. hasBeenCalledWithVoid determines if the Proxy was invoked without any arguments. hasBeenCalledWith determines if the Proxy was invoked with the given arguments. The arguments must follow the order of the Templates arguments but can contain gaps and do not need exhaustive. hasBeenStrictlyCalledWith determines if the Proxy was invoked with the given arguments. The arguments must follow the order of the Template arguments strictly and must provide all arguments in their order. hasBeenCalledWithout determines if the Proxy was invoked without the given arguments. PropertyProxies have their own specialized set of Expectation Methods: Method What it does wasGotten determines if the Proxy was invoked as a getter. wasSet determines if the Proxy was invoked as a setter. wasSetTo determines if the Proxy was invoked as a setter with the given argument.","title":"Expectations Method"},{"location":"howto/assertion/#argument-constraints","text":"While it might not always be desirable to assert/verify against an concrete value, KMock also offers ArgumentConstraints. For example if you simply want to confirm that a Proxy was called with a certain type you may do the following: @Test fun sampleTest () { val someInstance : SampleRemoteRepositoryMock = kmock () ... verify ( exactly = 1 ) { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) } } Internally all concrete types will be converted into an eq constraint. For example an Expectation Method is called with 42 . 42 will be converted into eq(42) . Currently the following constraints are implemented: ArgumentConstraint What it does and which allows to chain multiple values or constraints together with an logical and. any matches always (including null). If a concrete type was given it matches only if a recorded argument fulfils the expected type (exclusive null). eq matches if the recorded argument is equal to the expected argument. isNot matches if the recorded argument is not equal to the expected argument. isSame matches if the recorded argument is identical as the expected argument. isNotSame matches if the recorded argument is not identical as the expected argument. not matches if the negated outcome of a given ArgumentConstraint matches. or which allows to chain multiple values or constraints together with a logical or.","title":"Argument Constraints"},{"location":"howto/assertion/#single-proxy-assertionverification","text":"As you might now already seen KMock offers for Single Proxy Assertion/Verification verify and assertProxy . So what is now exactly the difference and what has that to do with the Expectation Methods? Well, verify will look if any invocation of the Proxy will match the given Expectation. assertProxy will go through the invocation from the first to latest. In short verify can skip invocations while assertProxy cannot. Also both functions are not capable to be used in order to make statements about the interactions between Proxies. However you can use assertProxy with multiple Proxies: @Test fun sampleTest () { val someInstance : SampleRemoteRepositoryMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) } verify ( atLeast = 1 ) { someInstance . _find . hasBeenCalledWith ( any ( String :: class )) } assertProxy { someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) someInstance . _fetch . hasBeenCalledWith ( any ( String :: class )) someInstance . _find . hasBeenCalledWith ( any ( String :: class )) } } As shown above you can and assuming fetch has been called 2x and with that _fetch was invoked 2x. Also assuming find was invoked, verify and assertProxy will pass. However you cannot say if fetch was called before or after find . Assuming now fetch has been called only once, verify will still pass, while assertProxy will fail. Since verify is less strict about the order it checks if a Proxy was invoked exactly , atLeast or atMost certain times. assertProxy on the other hand will always tell what is wrong with current and where but will only cover those invocation you told it cover. In order to ensure you covered all invocations via assertProxy you can use hasNoFurtherInvocations . Tip As a rule of thumb - if you want to cover a Proxy which is invoked multiple times you should consider using verify. If you cover a proxy which is invoked only once you should consider assertProxy . Note You need only one assertProxy per test case, strictly speaking. In terms of verify you need one per Verification.","title":"Single Proxy Assertion/Verification"},{"location":"howto/assertion/#experimental-operators","text":"Due to the special nature of verify KMock offers a additional way to make verify more versatile and expressive - Operators: Consider following source: interface SampleThing { fun method ( arg0 : String , arg1 : Int , arg2 : Any ) } Now you can use Operators with verify like : @Test fun sampleTest () { // arrange val someInstance : SampleThingMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _find . method ( \"payload\" , 23 , \"any\" ) or someInstance . _find . method ( \"payload\" , 42 , \"notAny\" ) } } Instead of: @Test fun sampleTest () { // arrange val someInstance : SampleThingMock = kmock () ... verify ( atLeast = 1 ) { someInstance . _find . method ( \"payload\" , or ( eq ( 23 ), eq ( 42 )), or ( eq ( \"any\" ), eq ( \"notAny\" ))) } } These Operators are still experimental but will become stable soon. Other Operators are: Operator What it does union resolves the union of 2 Expectations. or is an alias of union . intersection resolves the intersection of 2 Expectations. and is an alias of intersection . diff resolves the symmetrical difference of 2 Expectations. xor is an alias of diff","title":"Experimental Operators"},{"location":"howto/assertion/#multi-proxy-assertionverification","text":"To keep track of interaction between Proxies KMock offers also a way. You'll need to inject a Asserter/Verifier into the Mocks when they are initialized via the collector argument of kmock or kspy . Note Asserter and Verifier are the same. In fact Verifier is a type alias of Asserter. Import Make sure you use the fitting type of Asserter/Verifier according to the Memory Model . fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . assertOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } } KMock offers 3 flavours to deal with interaction of multiple Proxies - assertOrder , verifyStrictOrder and verifyOrder . assertOrder is super strict - you must cover all invocations of all collected Proxies in order and exhaustively. verifyStrictOrder is less strict - it allows you to skip an arbitrary number of invocations of Proxies, but once you started to verify them it acts like assertOrder . verifyOrder is even less strict but also less descriptive in terms of errors - it allows you to skip an arbitrary invocations of Proxies and will only care about the relative order of Proxies. All 3 flavours use the same API as verify/assertProxy to determine if a invocation is valid or not. For example: fun sampleTest () { // arrange val asserter = Asserter () val someInstance : SomeInterfaceMock = kmock ( collector = asserter ) val someInstanceOther : SomeInterfaceMock = kmock ( collector = asserter ) ... // assert asserter . verifOrder { someInstance . _someProperty . wasGotten () someInstanceOther . _someMethod . hasBeenCalled () someInstance . _someMethod . hasBeenCalled () } } To make the difference more clear: * assertOrder will fail if the invocation will not exactly in the order someProperty - someMethod - someMethod and there are more than these invocations. * verifyStrictOrder will fail if the invocation will not exactly in the order someProperty - someMethod - someMethod but it will not care if any invocation happens before that chain. * verifyOrder will fail if the invocation is not in the relative order someProperty - someMethod - someMethod but it will not care if any invocation happens before, after or in between them. Optionally you can use ensureVerificationOf if you need any insurance that all Proxies have been covered during a run by a Verifier/Asserter. Verifier/Asserter can additionally be initialised with the coverAllInvocations flag, which is false by default. This flag forces Proxies, which are excluded from Verification/Assertion by default to be covered during a test run. This is only important if you have to cover build-in methods like equals , since they are excluded from Verification via Verifier/Asserter by default due to their special nature.","title":"Multi Proxy Assertion/Verification"},{"location":"howto/assertion/#teardown","text":"As with Mocks Verifier/Asserter have a clear method, which opens them up for reuse. So do not forget to call it.","title":"Teardown"},{"location":"howto/assertion/#compatibility-with-proxy-access-methods","text":"In case you use Proxy Access Methods with Coroutines (aka asyncProxyOf ) you may have to use the corresponding Verification/Assertion methods. They act the very same way as they synchronous counter parts. The only difference is that they start with the prefix async like asyncVerify . Important Do not use them with direct Proxy Access together - their soul purpose is bound to asyncProxyOf and asyncProxyOf only.","title":"Compatibility with Proxy Access Methods"},{"location":"howto/install/","text":"Installation \u00b6 KMock is capable to work with a variety of projects. Preparation \u00b6 BuildScript BuildSrc In your build.gradle.kts: buildScript { repositories { ... mavenCentral () } dependencies { ... classpath ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } } allprojects { ... repositories { ... mavenCentral () } } In your buildSrc/build.gradle.kts: repositories { ... mavenCentral () } dependencies { implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } In your root project build.gradle.kts: allprojects { ... repositories { ... mavenCentral () } } In case you need to consume snapshots: BuildScript BuildSrc In your build.gradle.kts: buildScript { repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } ... allprojects { ... repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } In your buildSrc/build.gradle.kts: repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } ... In your root project build.grade.kts: allprojects { ... repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } Warning Snapshots are not meant to be stable and will be removed after a release. Also if you need a stable snapshot due to a specific issue please ask for a pined snapshot. Add it to your project \u00b6 Android JVM JS Kotlin Multiplatform plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kmock { rootPackage = \"my.root.package\" } android { ... sourceSets { ... // Note: Do not use this while running debug and release together aka check/test/build /*getByName(\"test\") { java.srcDirs( \"${project.buildDir.absolutePath.trimEnd('/')}/generated/ksp/debugUnitTest\", // Just to make the IDE happy ) }*/ } } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kmock { rootPackage = \"my.root.package\" } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } import tech.antibytes.gradle.kmock.KMockExtension ... plugins { id ( \"org.jetbrains.kotlin.js\" ) ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... } kmock { rootPackage = \"my.root.package\" } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } import tech.antibytes.gradle.kmock.KMockExtension ... plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... sourceSets { ... val commonTest by getting { dependencies { ... implementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } } ... } ... } kmock { rootPackage = \"my.root.package\" } Warning For KMP or KJs it is mandatory to configure KMock after your projects kotlin block has been set up as shown above. This is due to the fact that Kotlin brings its own system of source sets and Kotlin Symbol Processing (KSP) must be configured during the evaluation of your project. Tip You may find a full examples, how to set up KMock properly, in the Playground . Newer KSP or Kotlin Versions \u00b6 KMock eventually not use the latest version of Kotlin or KSP. This is mainly done to enable keep it open to projects which cannot update immediately. However since this might cause problems or noise you can force a new version of KSP: BuildScript BuildSrc In your build.gradle.kts: buildscript { ... dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\" ) classpath ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) { exclude ( group = \"com.google.devtools.ksp\" , module = \"symbol-processing-api\" ) exclude ( group = \"com.google.devtools.ksp\" , module = \"com.google.devtools.ksp.gradle.plugin\" ) } classpath ( \"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\" ) classpath ( \"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\" ) } } In your buildSrc/build.gradle.kts: dependencies { ... implementation ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\" ) implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) { exclude ( group = \"com.google.devtools.ksp\" , module = \"symbol-processing-api\" ) exclude ( group = \"com.google.devtools.ksp\" , module = \"com.google.devtools.ksp.gradle.plugin\" ) } implementation ( \"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\" ) implementation ( \"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\" ) } Warning Do not replace the Kotlin Version in the Runtime part of KMock!","title":"Installation"},{"location":"howto/install/#installation","text":"KMock is capable to work with a variety of projects.","title":"Installation"},{"location":"howto/install/#preparation","text":"BuildScript BuildSrc In your build.gradle.kts: buildScript { repositories { ... mavenCentral () } dependencies { ... classpath ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } } allprojects { ... repositories { ... mavenCentral () } } In your buildSrc/build.gradle.kts: repositories { ... mavenCentral () } dependencies { implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) } In your root project build.gradle.kts: allprojects { ... repositories { ... mavenCentral () } } In case you need to consume snapshots: BuildScript BuildSrc In your build.gradle.kts: buildScript { repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } ... allprojects { ... repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } In your buildSrc/build.gradle.kts: repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } ... In your root project build.grade.kts: allprojects { ... repositories { ... maven { url = java . net . URI ( \"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\" ) content { includeGroup ( \"tech.antibytes.kmock\" ) } } } } Warning Snapshots are not meant to be stable and will be removed after a release. Also if you need a stable snapshot due to a specific issue please ask for a pined snapshot.","title":"Preparation"},{"location":"howto/install/#add-it-to-your-project","text":"Android JVM JS Kotlin Multiplatform plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kmock { rootPackage = \"my.root.package\" } android { ... sourceSets { ... // Note: Do not use this while running debug and release together aka check/test/build /*getByName(\"test\") { java.srcDirs( \"${project.buildDir.absolutePath.trimEnd('/')}/generated/ksp/debugUnitTest\", // Just to make the IDE happy ) }*/ } } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kmock { rootPackage = \"my.root.package\" } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } import tech.antibytes.gradle.kmock.KMockExtension ... plugins { id ( \"org.jetbrains.kotlin.js\" ) ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... } kmock { rootPackage = \"my.root.package\" } dependencies { ... testImplementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } import tech.antibytes.gradle.kmock.KMockExtension ... plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... sourceSets { ... val commonTest by getting { dependencies { ... implementation ( \"tech.antibytes.kmock:kmock: $ KMockVersion \" ) ... } } ... } ... } kmock { rootPackage = \"my.root.package\" } Warning For KMP or KJs it is mandatory to configure KMock after your projects kotlin block has been set up as shown above. This is due to the fact that Kotlin brings its own system of source sets and Kotlin Symbol Processing (KSP) must be configured during the evaluation of your project. Tip You may find a full examples, how to set up KMock properly, in the Playground .","title":"Add it to your project"},{"location":"howto/install/#newer-ksp-or-kotlin-versions","text":"KMock eventually not use the latest version of Kotlin or KSP. This is mainly done to enable keep it open to projects which cannot update immediately. However since this might cause problems or noise you can force a new version of KSP: BuildScript BuildSrc In your build.gradle.kts: buildscript { ... dependencies { classpath ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\" ) classpath ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) { exclude ( group = \"com.google.devtools.ksp\" , module = \"symbol-processing-api\" ) exclude ( group = \"com.google.devtools.ksp\" , module = \"com.google.devtools.ksp.gradle.plugin\" ) } classpath ( \"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\" ) classpath ( \"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\" ) } } In your buildSrc/build.gradle.kts: dependencies { ... implementation ( \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\" ) implementation ( \"tech.antibytes.kmock:kmock-gradle: $ KMockVersion \" ) { exclude ( group = \"com.google.devtools.ksp\" , module = \"symbol-processing-api\" ) exclude ( group = \"com.google.devtools.ksp\" , module = \"com.google.devtools.ksp.gradle.plugin\" ) } implementation ( \"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\" ) implementation ( \"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\" ) } Warning Do not replace the Kotlin Version in the Runtime part of KMock!","title":"Newer KSP or Kotlin Versions"},{"location":"howto/proxy/","text":"Using Mocks \u00b6 Before you start \u00b6 Once you have declared the Mocks you are going to use, please run your test suite once. (Even if you have no meaningful tests defined yet.) This triggers the Code Generation of Mocks and you may benefit from autocompletion in your Editor or IDE right away. All Mocks (including Multi Interface Mocks) end on Mock to ensure a unified way to reference them. Proxies \u00b6 KMock will add double members - Proxy Properties - (do not confuse them with PropertyProxies ) to the generated Mock. All Proxy Properties are named with leading _ followed by the Templates original name. In case Templates are overloaded the proxy names will get additional suffix lead by With and derived from the Templates arguments types to ensure its uniqueness as much as possible. In case there is are still collisions you have additional options via KMocks Gradle Plugin Extension KMock in general distinguishes between PropertyProxies and FunProxies, which are referring to either to properties or methods of a Template. FunProxies \u00b6 FunProxies don't differentiate between asynchronous and synchronous in their API. Therefore anything works for both modi alike. KMock offers a simple way to facilitate stubbing. Consider following source: interface SampleRemoteRepository { suspend fun fetch ( url : String ): Any fun find ( id : String ): Any } You can deal with the resulting Mock for example like this: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . _fetch . returnValue = Any () someInstance . _find returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . execute () ... } In short KMock allows to assign canned values which are returned once the Template Method is invoked. In case you need a more elaborate behaviour you can use SideEffects: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . _fetch run { delay ( 20 ) return Any () } someInstance . _find . sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } You can use the following properties of FunProxies: Property What it does returnValue The Proxy will return the always the given value. returnValues The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. error The Proxy will throw the given error/exception. errors The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. sideEffect The Proxy will execute the given SideEffect and returns its result. sideEffects The Proxy will execute each SideEffect and returns its result. If only one SideEffect is left it will execute it until the run is completed. Note Please be aware there is a precedence of invocation. errors is used over error , returnValue is used over errors , returnValues is used over returnValues , sideEffect is used over returnValues and sideEffects is used over sideEffect . If no behaviour is set the Proxy simply fails and acts therefore intrusively. Additionally you can use the following infix methods to mutate its values: Method What it does returns Alias setter of returnValue . The Proxy will return the always the given value. returnsMany Alias setter of returnValues . The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. throws Alias setter of error . The Proxy will throw the given error/exception. throwsMany Alias setter of errors . The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. run Alias setter of sideEffect . The Proxy will execute the given SideEffect and returns its result. runs Alias setter of sideEffects . The Proxy will execute each SideEffect and returns its result. If only one SideEffect is left it will execute it until the run is completed. A last word to SideEffects. While they in general using the signature of the Template and therefore you can utilize the full power of the Kotlin's type system, there is 2 exceptions to this. If you work with Multi-Boundary Generics and declare them on Method level KMock cannot derive a certain type, since Kotlin has no Union Types per se. The same goes for recursive types as well (e.g. T : Comparable<T> ). Those types are derived as Any and you have to make sure to cast them correctly if you use them. PropertyProxies \u00b6 PropertyProxies work in a very similar fashion as FunProxies. Consider following source: interface SampleDomainObject { val id : String var something : Int } In short KMock allows to assign simple canned values which are returned once the Template Property is invoked: @Test fun sampleTest () { // arrange val someInstance : SampleDomainObjectMock = kmock () someInstance . _id . getValue = \"Any\" someInstance . _something . set = { value -> if ( value == 0 ) { throw RuntimeException () } } // act val someOtherInstance = SomeClass () someOtherInstance . execute ( someInstance ) ... } Property Setters are always using SideEffects but work completely non intrusive and have no need for a explicit setup. Property Getters can be use either stub values or a SideEffect. Both - Setter and Getter - do not allow multiple SideEffects since this should be considered as a clear sign that the usage of method is more appropriate instead. PropertyProxies have the following properties: Property What it does getValue The Proxy will return the always the given value. getValues The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. get The Proxy will execute the given SideEffect and return its result. set The Proxy will execute the given SideEffect. Note Please be aware there is a precedence of invocation. getValues is used over getValue and get is used over getValues . If no behaviour is set the Proxy simply fails and acts intrusively. Additionally you can use the following infix methods to set values: Method What it does returns Alias setter of getValue . Proxy will return the always the given value. returnsMany Alias setter of getValues . Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. runOnGet Alias setter of get . Proxy will execute the given SideEffect and return its result. runOnSet Alias setter of set . Proxy will execute the given SideEffect. ReceiverProxies \u00b6 While receivers are technically not a special type of Proxy they are still special. KMock will do what the compiler does with them and sees them as methods regardless if they are a property or not. The first argument of those methods will be always the type of the Receiver. In case the Template is a Property Receiver, KMock generates one or two methods which depends on the mutability of the Template Receiver. Additionally the generated Proxy is suffixed with Getter / Setter . In case the Template is a Method Receiver, KMock will just suffix the name with an additional Receiver . Unlike other libraries this makes it possible to access Receivers directly without the need of any workaround to reference them. The KMock Factory \u00b6 As you might already seen at this point KMock generates also Factories to ease the initialization of Mocks. kmock takes 4 arguments: collector , relaxed , relaxUnitFun and freeze . relax and relaxUnitFun determine if relaxing should be used and are false by default. freeze determines which flavour for the Memory Model is used and is true by default if no custom default value is set. In case of Single Interface Mocks and the Template uses Generics an additional argument is mandatory - templateType . This argument takes the KClass of the Template: @Test fun sampleTest () { // arrange val genericThing : SomethingGenericMock < Int > = kmock ( templateType = SomethingGeneric :: class , ) ... } In case of Multi-Interface Mocks and a Template uses Generics a additional arguments are mandatory - templateType$Idx . Those type take the KClass of the Templates: @Test fun sampleTest () { // arrange val genericThing : GenericMultiMock < Int , String , *> = kmock ( templateType0 = SomethingGeneric :: class , templateType1 = AnythingGeneric :: class , ) ... } Also KMock will not merge compatible Generic Types, since it cannot be sure if they are independent or not. This means if you reference the Mock you always have to explicitly declare all generics. Teardown \u00b6 All Mocks are generated with a _clearMock method which clears all Proxies owned by the Mock. This enables you to use Mocks per test suite and not only per test case: @MockCommon ( SampleInterface :: class , ... ) class SampleTestSet { private val someInstance : SomeInterfaceMock = kmock () @AfterTest fun tearDown () { someInstance . _clearMock () } @Test fun sampleTest () { ... } } Experimental Proxy Access Methods \u00b6 0.2.0 KMock introduces a new way to work with Proxies. This is done to provide a more robust way in terms of refactoring. However since those methods need a lot more thought and optimization they are considered as experimental but get hopefully soon in a much more stable state. Method What it does propertyProxyOf will reference a PropertyProxy syncFunProxyOf will reference a non suspending FunProxy. asyncFunProxyOf will reference a suspending FunProxy. For example they can used as followed: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . asyncFunProxyOf ( someInstance :: fetch ). sideEffect = { delay ( 20 ) return Any () } someInstance . asyncFunProxyOf ( someInstance :: find ). sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } In case you deal with overloaded methods or methods with generics you need to provide those methods a hint, which is composed of the argument types of the Template. Consider following source: interface SampleGenericRemoteRepositoryMock { suspend fun fetch (): Any suspend fun < T > fetch ( url : T ): Any fun find ( id : String ): Any fun find ( id : String , code : Int ): Any } Which my be address by: @Test fun sampleTest () { // arrange val someInstance : SampleGenericRemoteRepositoryMock = kmock () someInstance . asyncFunProxyOf < Any > ( someInstance :: fetch , hint < Any > ()). sideEffect = { delay ( 20 ) return Any () } someInstance . syncFunProxyOf ( someInstance :: find , hint < String , Int > ()). sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . execute () ... } While this may sound amazing these access method have their natural limitations due to Kotlin itself. You will not be able to address Receivers in that way. The signature of the Template maybe too ambiguous in certain cases which makes them unable to resolve the correct Proxy. In those cases you may access Proxies directly. Also you may encounter problems with incremental builds when you use expect/actual Aliases. In those cases take a look at preventResolvingOfAliases in the Gradle Plugin setup .","title":"Using Mocks"},{"location":"howto/proxy/#using-mocks","text":"","title":"Using Mocks"},{"location":"howto/proxy/#before-you-start","text":"Once you have declared the Mocks you are going to use, please run your test suite once. (Even if you have no meaningful tests defined yet.) This triggers the Code Generation of Mocks and you may benefit from autocompletion in your Editor or IDE right away. All Mocks (including Multi Interface Mocks) end on Mock to ensure a unified way to reference them.","title":"Before you start"},{"location":"howto/proxy/#proxies","text":"KMock will add double members - Proxy Properties - (do not confuse them with PropertyProxies ) to the generated Mock. All Proxy Properties are named with leading _ followed by the Templates original name. In case Templates are overloaded the proxy names will get additional suffix lead by With and derived from the Templates arguments types to ensure its uniqueness as much as possible. In case there is are still collisions you have additional options via KMocks Gradle Plugin Extension KMock in general distinguishes between PropertyProxies and FunProxies, which are referring to either to properties or methods of a Template.","title":"Proxies"},{"location":"howto/proxy/#funproxies","text":"FunProxies don't differentiate between asynchronous and synchronous in their API. Therefore anything works for both modi alike. KMock offers a simple way to facilitate stubbing. Consider following source: interface SampleRemoteRepository { suspend fun fetch ( url : String ): Any fun find ( id : String ): Any } You can deal with the resulting Mock for example like this: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . _fetch . returnValue = Any () someInstance . _find returns \"any\" // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . execute () ... } In short KMock allows to assign canned values which are returned once the Template Method is invoked. In case you need a more elaborate behaviour you can use SideEffects: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . _fetch run { delay ( 20 ) return Any () } someInstance . _find . sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } You can use the following properties of FunProxies: Property What it does returnValue The Proxy will return the always the given value. returnValues The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. error The Proxy will throw the given error/exception. errors The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. sideEffect The Proxy will execute the given SideEffect and returns its result. sideEffects The Proxy will execute each SideEffect and returns its result. If only one SideEffect is left it will execute it until the run is completed. Note Please be aware there is a precedence of invocation. errors is used over error , returnValue is used over errors , returnValues is used over returnValues , sideEffect is used over returnValues and sideEffects is used over sideEffect . If no behaviour is set the Proxy simply fails and acts therefore intrusively. Additionally you can use the following infix methods to mutate its values: Method What it does returns Alias setter of returnValue . The Proxy will return the always the given value. returnsMany Alias setter of returnValues . The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. throws Alias setter of error . The Proxy will throw the given error/exception. throwsMany Alias setter of errors . The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. run Alias setter of sideEffect . The Proxy will execute the given SideEffect and returns its result. runs Alias setter of sideEffects . The Proxy will execute each SideEffect and returns its result. If only one SideEffect is left it will execute it until the run is completed. A last word to SideEffects. While they in general using the signature of the Template and therefore you can utilize the full power of the Kotlin's type system, there is 2 exceptions to this. If you work with Multi-Boundary Generics and declare them on Method level KMock cannot derive a certain type, since Kotlin has no Union Types per se. The same goes for recursive types as well (e.g. T : Comparable<T> ). Those types are derived as Any and you have to make sure to cast them correctly if you use them.","title":"FunProxies"},{"location":"howto/proxy/#propertyproxies","text":"PropertyProxies work in a very similar fashion as FunProxies. Consider following source: interface SampleDomainObject { val id : String var something : Int } In short KMock allows to assign simple canned values which are returned once the Template Property is invoked: @Test fun sampleTest () { // arrange val someInstance : SampleDomainObjectMock = kmock () someInstance . _id . getValue = \"Any\" someInstance . _something . set = { value -> if ( value == 0 ) { throw RuntimeException () } } // act val someOtherInstance = SomeClass () someOtherInstance . execute ( someInstance ) ... } Property Setters are always using SideEffects but work completely non intrusive and have no need for a explicit setup. Property Getters can be use either stub values or a SideEffect. Both - Setter and Getter - do not allow multiple SideEffects since this should be considered as a clear sign that the usage of method is more appropriate instead. PropertyProxies have the following properties: Property What it does getValue The Proxy will return the always the given value. getValues The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. get The Proxy will execute the given SideEffect and return its result. set The Proxy will execute the given SideEffect. Note Please be aware there is a precedence of invocation. getValues is used over getValue and get is used over getValues . If no behaviour is set the Proxy simply fails and acts intrusively. Additionally you can use the following infix methods to set values: Method What it does returns Alias setter of getValue . Proxy will return the always the given value. returnsMany Alias setter of getValues . Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. runOnGet Alias setter of get . Proxy will execute the given SideEffect and return its result. runOnSet Alias setter of set . Proxy will execute the given SideEffect.","title":"PropertyProxies"},{"location":"howto/proxy/#receiverproxies","text":"While receivers are technically not a special type of Proxy they are still special. KMock will do what the compiler does with them and sees them as methods regardless if they are a property or not. The first argument of those methods will be always the type of the Receiver. In case the Template is a Property Receiver, KMock generates one or two methods which depends on the mutability of the Template Receiver. Additionally the generated Proxy is suffixed with Getter / Setter . In case the Template is a Method Receiver, KMock will just suffix the name with an additional Receiver . Unlike other libraries this makes it possible to access Receivers directly without the need of any workaround to reference them.","title":"ReceiverProxies"},{"location":"howto/proxy/#the-kmock-factory","text":"As you might already seen at this point KMock generates also Factories to ease the initialization of Mocks. kmock takes 4 arguments: collector , relaxed , relaxUnitFun and freeze . relax and relaxUnitFun determine if relaxing should be used and are false by default. freeze determines which flavour for the Memory Model is used and is true by default if no custom default value is set. In case of Single Interface Mocks and the Template uses Generics an additional argument is mandatory - templateType . This argument takes the KClass of the Template: @Test fun sampleTest () { // arrange val genericThing : SomethingGenericMock < Int > = kmock ( templateType = SomethingGeneric :: class , ) ... } In case of Multi-Interface Mocks and a Template uses Generics a additional arguments are mandatory - templateType$Idx . Those type take the KClass of the Templates: @Test fun sampleTest () { // arrange val genericThing : GenericMultiMock < Int , String , *> = kmock ( templateType0 = SomethingGeneric :: class , templateType1 = AnythingGeneric :: class , ) ... } Also KMock will not merge compatible Generic Types, since it cannot be sure if they are independent or not. This means if you reference the Mock you always have to explicitly declare all generics.","title":"The KMock Factory"},{"location":"howto/proxy/#teardown","text":"All Mocks are generated with a _clearMock method which clears all Proxies owned by the Mock. This enables you to use Mocks per test suite and not only per test case: @MockCommon ( SampleInterface :: class , ... ) class SampleTestSet { private val someInstance : SomeInterfaceMock = kmock () @AfterTest fun tearDown () { someInstance . _clearMock () } @Test fun sampleTest () { ... } }","title":"Teardown"},{"location":"howto/proxy/#experimental-proxy-access-methods","text":"0.2.0 KMock introduces a new way to work with Proxies. This is done to provide a more robust way in terms of refactoring. However since those methods need a lot more thought and optimization they are considered as experimental but get hopefully soon in a much more stable state. Method What it does propertyProxyOf will reference a PropertyProxy syncFunProxyOf will reference a non suspending FunProxy. asyncFunProxyOf will reference a suspending FunProxy. For example they can used as followed: @Test fun sampleTest () { // arrange val someInstance : SampleRemoteRepositoryMock = kmock () someInstance . asyncFunProxyOf ( someInstance :: fetch ). sideEffect = { delay ( 20 ) return Any () } someInstance . asyncFunProxyOf ( someInstance :: find ). sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . run () ... } In case you deal with overloaded methods or methods with generics you need to provide those methods a hint, which is composed of the argument types of the Template. Consider following source: interface SampleGenericRemoteRepositoryMock { suspend fun fetch (): Any suspend fun < T > fetch ( url : T ): Any fun find ( id : String ): Any fun find ( id : String , code : Int ): Any } Which my be address by: @Test fun sampleTest () { // arrange val someInstance : SampleGenericRemoteRepositoryMock = kmock () someInstance . asyncFunProxyOf < Any > ( someInstance :: fetch , hint < Any > ()). sideEffect = { delay ( 20 ) return Any () } someInstance . syncFunProxyOf ( someInstance :: find , hint < String , Int > ()). sideEffect = { id -> return if ( id . isEmpty ()) { throw RuntimeException () } else { Any () } } // act val someOtherInstance = SomeClass ( someInstance ) someOtherInstance . execute () ... } While this may sound amazing these access method have their natural limitations due to Kotlin itself. You will not be able to address Receivers in that way. The signature of the Template maybe too ambiguous in certain cases which makes them unable to resolve the correct Proxy. In those cases you may access Proxies directly. Also you may encounter problems with incremental builds when you use expect/actual Aliases. In those cases take a look at preventResolvingOfAliases in the Gradle Plugin setup .","title":"Experimental Proxy Access Methods"},{"location":"howto/setup/","text":"Setup \u00b6 Mandatory Options \u00b6 KMock brings a variety of configuration options. In order to access KMock's extension in Gradle please do the following: plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... } kmock { rootPackage = \"my.root.package\" } The only mandatory option is rootPackage , It expects the root package of your project as a String. This information is need in order to arrange the generate Mocks properly. Optional Features \u00b6 Aliases \u00b6 In order to resolve conflicts of mock names KMock allows you make mapping of aliases via aliasNameMapping . It expects a the key of the full qualified name of the Template and as value the Alias as a short name: kmock { ... rootPackage = \"my.root.package\" aliasNameMapping = mapOf ( \"my.root.package.template.alias.Collision\" to \"Alias\" , ) } Build-In Methods \u00b6 KMock will not generate proxies for Build-In methods like hashCode by default in order to avoid unnecessary overhead. However if you need Build-In methods you can tell KMock to generate them via useBuildInProxiesOn . It expects a set of full qualified names of Templates which should have proxies for Build-In methods: kmock { ... rootPackage = \"my.root.package\" useBuildInProxiesOn = setOf ( \"my.root.package.template.alias.BuildInMethods\" ) } Colliding Method Names \u00b6 If KMock produces a collision of names for overloaded methods you can resolve it via useTypePrefixFor . It expects a map, while the key must be the full qualified name of causing type and the value is an arbitrary String, which is used as a prefix. kmock { ... rootPackage = \"my.root.package\" useTypePrefixFor = mapOf ( \"my.root.package.types.overloaded.Scope.Abc\" to \"Prefix\" ) } Spies \u00b6 In order to enable Spies for certain Templates, KMock offers you the spyOn . It expects a set of full qualified names of Templates. Note This will enable Build-In methods for this particular mock as well. Note Spies for Multi-Mocks will triggered if one Interface can be spied on. kmock { ... rootPackage = \"my.root.package\" spyOn = setOf ( \"my.root.package.templates.spy.SpyOnMe\" ) } Spy on All \u00b6 By default KMock will only activate spies via spyOn . If you simply want to enable spying for all Templates spies you can do that via spyAll : kmock { ... rootPackage = \"my.root.package\" spyAll = true } Spies only \u00b6 If you have no use for Mocks which cannot be spied and you want to spare the compile time of the kmock factories, you may tell this KMock via spiesOnly : kmock { ... rootPackage = \"my.root.package\" spiesOnly = true } Note spiesOnly will trigger that all Mocks can are spied on like spyAll . Enable Interface References \u00b6 In order to be able to utilize interfaces for the kmock or kspy factory you can enable this via allowInterfaces : Tip This will be handy if you use it together with Relaxation. Note This will not work for Multi Interface Mocks. kmock { ... rootPackage = \"my.root.package\" allowInterfaces = true } Default Freezing behaviour \u00b6 By the default all Mocks are frozen in order to avoid any issues which can occur with Coroutines. If you do not wish that default you can set a new one via freezeOnDefault : kmock { ... rootPackage = \"my.root.package\" freezeOnDefault = false } Disable Factories \u00b6 One of the biggest factors in terms of compile time are the generated factories. If you do not mind to wire everything by hand you can disable them via disableFactories : Warning If you do that you are on your own. Also constructors of Mocks are considered as internal. This means do not expect them to have a stable API. kmock { ... rootPackage = \"my.root.package\" disableFactories = true } Custom Annotations for Shared Sources \u00b6 In order to ease the declaration of Mocks for Shared Sources (e.g. nativeTest ) KMock offers you a hook to define custom annotations via customAnnotationsForMeta . It takes a map. The key must be the full qualified name of your Annotation and the value a (valid) Source Set your Annotations is referring to. Note Before you ask - no, inheritance does not work with annotations. Important commonTest as Source Set is not allowed! kmock { ... rootPackage = \"my.root.package\" customAnnotationsForMeta = mapOf ( \"my.root.package.annotation.Native\" to \"nativeTest\" ) } Experimental Features \u00b6 The following features are considered as experimental, which means there likely be to changed or removed. CustomMethodNames \u00b6 Since overloaded method names of Proxies can become very ugly KMock offers you the possibility to rename them via customMethodNames . It expects a map while the key must be the full id of the Proxy you are referring to and the value can be an arbitrary String, which is used as name for the Proxy. Warning This feature will hurt you if the Template is subject to changes, since you have to adjust the mapping each time. kmock { ... rootPackage = \"my.root.package\" customAnnotationsForMeta = mapOf ( \"my.root.package.template.renamed.OverloadedMock#_foo\" to \"bar\" ) } Proxy Access Methods \u00b6 In order to enable the experimental ProxyAccessMethods you can switch allowExperimentalProxyAccess to true: kmock { ... rootPackage = \"my.root.package\" allowExperimentalProxyAccess = true } Fine Grained ProxyNames \u00b6 If you have the need of Proxy names which support the full extend of KMP deferring types you can enable enableFineGrainedNames . Note You will not need that if you work with JVM or Android. This flag will you only help withs native sources and JS. kmock { ... rootPackage = \"my.root.package\" enableFineGrainedNames = true } Prevent resolving of Aliases \u00b6 It may occur that AccessMethods in combination with expect/actual Aliases cause problems with incremental builds. Since it is currently not possible to resolve that automatically you need to declare them by hand: kmock { ... rootPackage = \"my.root.package\" preventResolvingOfAliases = \"my.root.package.subpacke.Alias\" }","title":"Setup"},{"location":"howto/setup/#setup","text":"","title":"Setup"},{"location":"howto/setup/#mandatory-options","text":"KMock brings a variety of configuration options. In order to access KMock's extension in Gradle please do the following: plugins { ... id ( \"tech.antibytes.kmock.kmock-gradle\" ) } kotlin { ... } kmock { rootPackage = \"my.root.package\" } The only mandatory option is rootPackage , It expects the root package of your project as a String. This information is need in order to arrange the generate Mocks properly.","title":"Mandatory Options"},{"location":"howto/setup/#optional-features","text":"","title":"Optional Features"},{"location":"howto/setup/#aliases","text":"In order to resolve conflicts of mock names KMock allows you make mapping of aliases via aliasNameMapping . It expects a the key of the full qualified name of the Template and as value the Alias as a short name: kmock { ... rootPackage = \"my.root.package\" aliasNameMapping = mapOf ( \"my.root.package.template.alias.Collision\" to \"Alias\" , ) }","title":"Aliases"},{"location":"howto/setup/#build-in-methods","text":"KMock will not generate proxies for Build-In methods like hashCode by default in order to avoid unnecessary overhead. However if you need Build-In methods you can tell KMock to generate them via useBuildInProxiesOn . It expects a set of full qualified names of Templates which should have proxies for Build-In methods: kmock { ... rootPackage = \"my.root.package\" useBuildInProxiesOn = setOf ( \"my.root.package.template.alias.BuildInMethods\" ) }","title":"Build-In Methods"},{"location":"howto/setup/#colliding-method-names","text":"If KMock produces a collision of names for overloaded methods you can resolve it via useTypePrefixFor . It expects a map, while the key must be the full qualified name of causing type and the value is an arbitrary String, which is used as a prefix. kmock { ... rootPackage = \"my.root.package\" useTypePrefixFor = mapOf ( \"my.root.package.types.overloaded.Scope.Abc\" to \"Prefix\" ) }","title":"Colliding Method Names"},{"location":"howto/setup/#spies","text":"In order to enable Spies for certain Templates, KMock offers you the spyOn . It expects a set of full qualified names of Templates. Note This will enable Build-In methods for this particular mock as well. Note Spies for Multi-Mocks will triggered if one Interface can be spied on. kmock { ... rootPackage = \"my.root.package\" spyOn = setOf ( \"my.root.package.templates.spy.SpyOnMe\" ) }","title":"Spies"},{"location":"howto/setup/#spy-on-all","text":"By default KMock will only activate spies via spyOn . If you simply want to enable spying for all Templates spies you can do that via spyAll : kmock { ... rootPackage = \"my.root.package\" spyAll = true }","title":"Spy on All"},{"location":"howto/setup/#spies-only","text":"If you have no use for Mocks which cannot be spied and you want to spare the compile time of the kmock factories, you may tell this KMock via spiesOnly : kmock { ... rootPackage = \"my.root.package\" spiesOnly = true } Note spiesOnly will trigger that all Mocks can are spied on like spyAll .","title":"Spies only"},{"location":"howto/setup/#enable-interface-references","text":"In order to be able to utilize interfaces for the kmock or kspy factory you can enable this via allowInterfaces : Tip This will be handy if you use it together with Relaxation. Note This will not work for Multi Interface Mocks. kmock { ... rootPackage = \"my.root.package\" allowInterfaces = true }","title":"Enable Interface References"},{"location":"howto/setup/#default-freezing-behaviour","text":"By the default all Mocks are frozen in order to avoid any issues which can occur with Coroutines. If you do not wish that default you can set a new one via freezeOnDefault : kmock { ... rootPackage = \"my.root.package\" freezeOnDefault = false }","title":"Default Freezing behaviour"},{"location":"howto/setup/#disable-factories","text":"One of the biggest factors in terms of compile time are the generated factories. If you do not mind to wire everything by hand you can disable them via disableFactories : Warning If you do that you are on your own. Also constructors of Mocks are considered as internal. This means do not expect them to have a stable API. kmock { ... rootPackage = \"my.root.package\" disableFactories = true }","title":"Disable Factories"},{"location":"howto/setup/#custom-annotations-for-shared-sources","text":"In order to ease the declaration of Mocks for Shared Sources (e.g. nativeTest ) KMock offers you a hook to define custom annotations via customAnnotationsForMeta . It takes a map. The key must be the full qualified name of your Annotation and the value a (valid) Source Set your Annotations is referring to. Note Before you ask - no, inheritance does not work with annotations. Important commonTest as Source Set is not allowed! kmock { ... rootPackage = \"my.root.package\" customAnnotationsForMeta = mapOf ( \"my.root.package.annotation.Native\" to \"nativeTest\" ) }","title":"Custom Annotations for Shared Sources"},{"location":"howto/setup/#experimental-features","text":"The following features are considered as experimental, which means there likely be to changed or removed.","title":"Experimental Features"},{"location":"howto/setup/#custommethodnames","text":"Since overloaded method names of Proxies can become very ugly KMock offers you the possibility to rename them via customMethodNames . It expects a map while the key must be the full id of the Proxy you are referring to and the value can be an arbitrary String, which is used as name for the Proxy. Warning This feature will hurt you if the Template is subject to changes, since you have to adjust the mapping each time. kmock { ... rootPackage = \"my.root.package\" customAnnotationsForMeta = mapOf ( \"my.root.package.template.renamed.OverloadedMock#_foo\" to \"bar\" ) }","title":"CustomMethodNames"},{"location":"howto/setup/#proxy-access-methods","text":"In order to enable the experimental ProxyAccessMethods you can switch allowExperimentalProxyAccess to true: kmock { ... rootPackage = \"my.root.package\" allowExperimentalProxyAccess = true }","title":"Proxy Access Methods"},{"location":"howto/setup/#fine-grained-proxynames","text":"If you have the need of Proxy names which support the full extend of KMP deferring types you can enable enableFineGrainedNames . Note You will not need that if you work with JVM or Android. This flag will you only help withs native sources and JS. kmock { ... rootPackage = \"my.root.package\" enableFineGrainedNames = true }","title":"Fine Grained ProxyNames"},{"location":"howto/setup/#prevent-resolving-of-aliases","text":"It may occur that AccessMethods in combination with expect/actual Aliases cause problems with incremental builds. Since it is currently not possible to resolve that automatically you need to declare them by hand: kmock { ... rootPackage = \"my.root.package\" preventResolvingOfAliases = \"my.root.package.subpacke.Alias\" }","title":"Prevent resolving of Aliases"},{"location":"howto/terminology/","text":"Terminology \u00b6 Just to prevent any confusion about terms let's make some quick definitions: A Proxy relates to a single property (PropertyProxy) or method (FunProxy). A Mock owns multiple Proxies based on an given Interface. Interfaces and their members are used as Templates for Proxies or a Mock. Assertion is strict about order which makes them fail in place and they are absolute/explicit about what they cover. Verification fails after they traversed all available sources, which means they can skip elements.","title":"Terminology"},{"location":"howto/terminology/#terminology","text":"Just to prevent any confusion about terms let's make some quick definitions: A Proxy relates to a single property (PropertyProxy) or method (FunProxy). A Mock owns multiple Proxies based on an given Interface. Interfaces and their members are used as Templates for Proxies or a Mock. Assertion is strict about order which makes them fail in place and they are absolute/explicit about what they cover. Verification fails after they traversed all available sources, which means they can skip elements.","title":"Terminology"}]}