= KMock
:link-base: https://github.com/bitPogo
:link-repository: {link-base}/kmock
:link-docs: {link-repository}/tree/main/docs
:link-api: {link-docs}/api
:author: Matthias Geisler
:revnumber: 1.0
:project-version: 0.1.0
:doctype: article
:toc: macro
:toclevels: 4
:toc-title:
:icons: font
:imagesdir: assets/images
:lang: en
ifdef::env-github[]
:warning-caption: :warning:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
endif::[]

[discrete]
== Table Of Contents

toc::[]

== Starter Guide

NOTE: KMock is currently published via link:https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-gradle-registry#using-a-published-package[GitHub Packages].
If it finds sufficient appreciation it will migrate to MavenCentral.

=== Preparation

In order to consume KMock please add the following code into your _buildSrc_'s and project's _build.gradle(.kts)_:

[source, kotlin]
----
repositories {
   ..
   maven {
      url = uri("https://maven.pkg.github.com/bitPogo/kmock")
      credentials {
          username = project.findProperty("gpr.user") ?: System.getenv("PACKAGE_REGISTRY_USERNAME")
          password = project.findProperty("gpr.key") ?: System.getenv("PACKAGE_REGISTRY_DOWNLOAD_TOKEN")
      }
}
----

You may find a description what it does link:https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-gradle-registry#using-a-published-package[here].

=== Installation

==== Include the plugin into your buildSrc

Include the plugin into your link:https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources[buildSrc]:

[source, kotlin]
----
dependencies {
   ..
   implementation("tech.antibytes.kmock:kmock-gradle:$KMockVersion")
   ..
}

..

----

==== Installation for JVM Projects

[source, kotlin]
----
plugins {
   ..
   id("tech.antibytes.kmock.kmock-gradle")
}

kmock {
   rootPackage = "my.root.package"
}

dependencies {
   ..
   testImplementation("tech.antibytes.kmock:kmock:$KMockVersion")
   ..
}

..

----

==== Installation for Kotlin Js Projects

[source, kotlin]
----
plugins {
   id("org.jetbrains.kotlin.js")

   ..

   id("tech.antibytes.kmock.kmock-gradle") apply false
}

kotlin {
   ..
}

plugins.apply("tech.antibytes.kmock.kmock-gradle")

project.extensions.configure<KMockExtension>(KMockExtension::class.java) {
   rootPackage = "my.root.package"
}

dependencies {
   ..

   testImplementation("tech.antibytes.kmock:kmock:$KMockVersion")

   ..
}

----

==== Installation for Multi-Platform Projects

[source, kotlin]
----
plugins {
   ..

   id("tech.antibytes.kmock.kmock-gradle") apply false
}

kotlin {
   ..

   sourceSets {
       ..
       val commonTest by getting {
           dependencies {
               ..
               implementation("tech.antibytes.kmock:kmock:$KMockVersion")
               ..
           }
       }
       ..
   }
   ..
}

plugins.apply("tech.antibytes.kmock.kmock-gradle")

project.extensions.configure<KMockExtension>("kmock") {
   rootPackage = "my.root.package"
}

..

----

In order to bring KMock to life you must tell it about the root package of your project in the Extension of the KMock's Gradle Plugin via the `rootPackage` property as shown above. This is simply needed to arrange things right, while generating Mocks.

IMPORTANT: The plugin must be applied for KMP or KJs projects after `kotlin` has been set up as shown above.
This is due to the fact that Kotlin brings its own system of source sets and link:https://github.com/google/ksp[Kotlin Symbol Processing (KSP)]
must be configured during the evaluation of the project.

TIP: You find a full examples, how to set up KMock properly in the link:{link-base}/kmock-playground[Playground].

NOTE: In case you experience a name collision of Mocks you can delegate a map to resolve that issue via `aliasNameMapping`.
The key must be the full qualified name of the interface which should use an alias.
The value must be a string which starts with a latin letter (a-Z) followed by a latin letter or a number (a-Z0-9).

=== Terminology
Just not get confused by terminology 2 terms upfront which are important - Mock and Proxy.
A Proxy relates to a single property (PropertyProxy) or method (FunProxy).
A Mock owns multiple Proxies based on an given Interface.
The Interface and its members are used as Templates for Proxies or a Mock.

=== Declaring Mocks
You can declare Mocks in a central place (per platform) or per test suite.
However declaring them in a central place is discouraged since it violates the link:https://enterprisecraftsmanship.com/posts/dry-damp-unit-tests/[DAMP unit tests] principle. +
You may declare Mocks as followed:

.Declare Mocks for Common Code
[source, kotlin]
----
..
import tech.antibytes.kmock.MockCommon
..

@MockCommon(
   SampleInterface::class,
   OtherSampleInterface::class,
   ..
)
class SampleTestSet {
   ..
}

----

.Declare Mocks for arbitrary Shared Code
[source, kotlin]
----
..
import tech.antibytes.kmock.MockShared
..

@MockShared(
   "sourceSetName",
   SampleInterface::class,
   OtherSampleInterface::class,
   ..
)
class SampleTestSet {
   ..
}

----

IMPORTANT: You must set a SourceSetName if you use `MockShared`.
KMock needs to know where the Interfaces and therefore the generated Mocks belong to.
For example if you mock sources in `nativeTest` use it (`nativeTest`) as the SourceSetName.
Also `MockShared` will not accept `commonTest` as SourceSetName, since this special case has to go through `MockCommon`.


.Declare Mocks for Platform Code
[source, kotlin]
----
..
import tech.antibytes.kmock.Mock
..

@Mock(
   SampleInterface::class,
   OtherSampleInterface::class,
   ..
)
class SampleTestSet {
   ..
}

----

As you already noticed KMock will *only* allow you to mock *Interfaces*.
This is simply due to the fact that for KMP there is no way to manipulate things at runtime in the same way as link:https://mockk.io/[MockK] can do it.
This means everything will be generated upfront, which can lead to collisions of names of Mocks.
KMock will let you set an alias name if you experience collisions via `aliasNameMapping` in its Gradle Plugin Extension.
It takes a map where the key must be the full qualified name of the Interface which should use an alias for its Mock.
The value must be a string which starts with a latin letter (a-Z) followed by a latin letter or a number (a-Z0-9).

=== Using KMock

Once you have declared the Mocks you are going to use, please run your test suite once even if you have no meaningful tests defined.
This triggers the Generation the Mocks and you may benefit from autocompletion in your Editor or IDE right away.
After that you can start to write your tests:

.Example Test
[source,kotlin]
----
@Test
fun sampleTest() {
   // arrange
   val someInstance: SomeInterfaceMock = kmock()

   someInstance._someProperty.returns = "any"
   someInstance._someMethod.returns = "any"

   // act
   val someOtherInstance = SomeClass(someInstance)
   someOtherInstance.run()

   // assert
   someInstance._someProperty.assertWasGotten(exactly = 1)
   someInstance._someMethod.assertHasBeenCalled(exactly = 1)
}
----

KMock will add double members - _Proxy Properties_ - (do not confuse them with _PropertyProxies_) to the generated Mock.
All Proxy Properties are named with `_` as prefix followed by the Templates original name, except overloaded for names. +
In cases where a name is used multiple times it acts a bit different.
It will add additionally the parameter types to names for Proxy Properties, which are binding a _FunProxy_ to keep the name unique.
This might lead to some weird cases, since the type may contain a prefix which is useless (e.g. `kotlin.collections`, which gets converted into `KotlinCollections`).
Since this can really hurt readability and fun, KMock lets you remove those prefixes via the `uselessPrefixes` property of the Gradle Plugin Extension.

==== FunProxies

FunProxies don't differentiate between asynchronous and synchronous, while you assign them values.
Therefore anything works for both modi alike. +
KMock offers a simple way to facilitate stubbing as shown before.
You can use the following properties for stubbing:

[cols=2*]
|===
| Property
| What it does

| `returns`
| the Proxy will return the always the given value.

| `returnMany`
| the Proxy will return each value of the given list.
If only one value is left it will return it until the run is completed.

| `throws`
| throws a given error/exception.
|===

In case you need elaborated behaviour, which takes for example arguments into account, you can use _SideEffects_. +
SideEffects are in principle lambdas with a identical signature of the Template method:

.Example Source
[source, kotlin]
----
interface SampleRemoteRepository {
   suspend fun fetch(url: String): Any
   fun find(id: String): Any
}
----

.Example Test with SideEffect
[source, kotlin]
----
..
@Test
fun sampleTest() {
   val someInstance: SampleRemoteRepositoryMock = kmock()

   someInstance._fetch.sideEffect = {
       delay(20)
       return Any()
   }

   someInstance._find.sideEffect = { id ->
       return if (id.isEmpty()) {
           throw RuntimeException()
       } else {
           Any()
       }
   }
}
..
----

If you want to chain several SideEffects together, while keeping them in small packages, you may consider using the `sideEffects` property of a FunProxy.
This property contains a builder to chain multiple SideEffects together.
Similar to `returnsMany` it will repeat the execution of the last assigned SideEffect until the run is complete, if the chain is otherwise exhausted. +

IMPORTANT: Please be aware there is a precedence of invocation.
`returns` is used over `throws`, `returnsMany` is used over `returns`, `sideEffect` is used over `returnsMany` and `sideEffects` is used over `sideEffect`.
If no behaviour is set the Proxy simply fails and acts therefore intrusively.

While SideEffects are in general type safe there is one exception to this - link:https://kotlinlang.org/docs/generics.html[Multi-Boundary Generics] which are declared on method level:

.Multi-Bounded Generic
[source, kotlin]
----
interface SampleThing {
   fun <T> doSomething(payload: T) where T : SomeOtherInterface<String>, T : SomeAnyInterface<String>
}
----

`payload` and the return type will be resolved as `Any` for the generated SideEffect.
You'll need to cast the provided arguments and return value accordingly to avoid any errors. +
If you end up in such a situation, maybe consider combining those boundaries into a single interface. +
KMock also allows you to proxy build-in methods like `toString`.
The Gradle Extension offers you a field called `useBuildInProxiesOn` for that purpose.
It takes a set of the full qualified names of the targeted Interfaces in order to select them.
Use those Proxy with caution and only if the intended implementation of the mocked Interface requires/has special behaviour or attention.
Also the Proxies of those methods do not require any additional setup to act non intrusively, since they always fall back to default behaviour of its parent.

==== PropertyProxies

PropertyProxies work similarly to FunProxies.
Therefore they have similar stubbing capabilities:

[cols=2*]
|===
| Property
| What it does

| `get`
| the Proxy will return always the given value if the getter is called.

| `getMany`
| the Proxy will return each value of the given list if the getter is called.
If only one value is left it will return it until the run is completed.

| `getSideEffect`
| the Proxy executes the given SideEffect if the getter is called.

| `set`
| the Proxy executes the given SideEffect if the setter is called.

|===

PropertyProxies do not allow chaining of SideEffects since this should be considered as a clear sign that the usage of method is more appropriate instead.

IMPORTANT: Please be aware there is a precedence of invocation.
`getMany` is used over `get` and `getSideEffect` is used over `getMany`.
If no behaviour is set the Proxy simply fails and acts intrusively.

==== Verification/Assertion
===== Verification of a single Proxy

For single Proxies you can either use Verification or Assertions:

.Example Test with Verification style
[source, kotlin]
----
..
@Test
fun sampleTest() {
   val someInstance: SampleRemoteRepositoryMock = kmock()
   ..

   // Verification
   verify(exactly = 1) { someInstance._fetch.hasBeenCalledWith("someUrl") }
   verify(exactly = 1) { someInstance._find.hasBeenCalledWith("something") }
}

----

IMPORTANT: `verify` will only take the latest _Expectation_ into account.

.Example Test with Assertion style
[source, kotlin]
----
..
@Test
fun sampleTest() {
   val someInstance: SampleRemoteRepositoryMock = kmock()
   ..

   // Assertion
   someInstance._fetch.assertHasBeenCalledWith("someUrl") }
   someInstance._find.assertHasBeenCalledWith("something")
}

----

CAUTION: Assertions are currently limited and considered as experimental.
They need further evaluation if they are suitable concepts or if they are less idiomatic.
This means they might get removed or changed in the future.

While Assertions use a single method attached to a Proxy, Verification uses a _Expectation Method_ inside of a Verification Block.
If you use Verification you can additionally combine multiple Expectations:

.Example Test with combined Verification
[source, kotlin]
----
..
@Test
fun sampleTest() {
   val someInstance: SampleRemoteRepositoryMock = kmock()
   ..

   verify(exactly = 1) {
       someInstance._fetch.hasBeenCalledWith("someUrl") and someInstance._fetch.hasBeenCalledWithout("someOtherUrl")
   }
}

----

CAUTION: As with Assertions consider combining as an experimental feature, which might get removed in the future, depending on its usefulness.

You have the following Expectation Methods for FunProxies:

[cols=2*]
|===
| Method
| What it does

| `hasBeenCalled`
| determines if the Proxy was invoked.

| `hasBeenCalledWithVoid`
| determines if the Proxy was invoked without any arguments.

| `hasBeenCalledWith`
| determines if the Proxy was invoked with the given arguments.
The arguments must follow the order of the Template signature but can contain gaps and do not need all arguments.

| `hasBeenStrictlyCalledWith`
| determines if the Proxy was invoked with the given arguments.
The arguments must follow the order of the Template signature strictly and must provide all arguments.

| `hasBeenCalledWithout`
| determines if the Proxy was invoked without the given arguments.

|===

Alternatively you may use the following Assertions:

[cols=2*]
|===
| Method
| What it does

| `assertHasBeenCalled`
| determines if the Proxy was invoked.

| `assertHasBeenCalledWithVoid`
| determines if the Proxy was invoked without any arguments.

| `assertHasBeenCalledWith`
| determines if the Proxy was invoked with the given arguments.
The arguments must follow the order of the Template signature but can contain gaps and do not need all arguments.

| `assertHasBeenCalledStrictlyWith`
| determines if the Proxy was invoked with the given arguments.
The arguments must follow the order of the Template signature strictly and must provide all arguments.

| `assertHasNotBeenCalled`
| determines if the Proxy was not invoked.

| `assertHasBeenCalledWithout`
| determines if the Proxy was invoked without the given arguments.

|===

For PropertyProxies you can use the following Expectation Methods:

[cols=2*]
|===
| Method
| What it does

| `wasGotten`
| determines if the Proxy was invoked as a getter.

| `wasSet`
| determines if the Proxy was invoked as a setter.

| `wasSetTo`
| determines if the Proxy was invoked as a setter with the given argument.

|===

Or the following Assertions:

[cols=2*]
|===
| Method
| What it does

| `assertWasGotten`
| determines if the Proxy was invoked as getter.

| `assertWasSet`
| determines if the Proxy was invoked as setter.

| `assertWasSetTo`
| determines if the Proxy was invoked as setter with the given argument.

|===

FunProxy and PropertyProxy Expectation Methods can make use of the following Operators (for combining):

[cols=2*]
|===
| Method
| What it does

| `union`
| resolves union of 2 Expectation Method outcomes.

| `or`
| is an alias to `union`.

| `intersection`
| resolves the intersection of 2 Expectation Method outcomes.

| `and`
| is an alias to `intersection`.

| `diff`
| resolves the symmetrical difference of 2 Expectation Method outcomes.

| `xor`
| is an alias to `diff`.

|===

===== ArgumentConstrains

While it might not always be desirable to assert/verify against a concrete value, KMock also offers ArgumentConstraints.
For example if you simply want to confirm that a Proxy was called with a certain type you may do the following:

.Example Test with ArgumentConstraint
[source, kotlin]
----
..
@Test
fun sampleTest() {
   val someInstance: SampleRemoteRepositoryMock = kmock()
   ..

   verify(exactly = 1) {
       someInstance._fetch.hasBeenCalledWith(any(String::class))
   }
}

----

Internally all concrete types will be converted in a `eq` constraint.
For example an assertion/expectation which is called with `42` will be converted into `eq(42)`.
Currently the following constraints are implemented:

[cols=2*]
|===
| ArgumentConstraint
| What it does

| `any`
| matches always (including null).
If a concrete type was given it matches only if a recorded argument fulfils the expected type (exclusive null).

| `eq`
| matches if the recorded argument is equal to the expected argument.

| `isNot`
| matches if the recorded argument is not equal to the expected argument.

| `isSame`
| matches if the recorded argument is identical as the expected argument.

| `isNotSame`
| matches if the recorded argument is not identical as the expected argument.

|===

ArgumentConstraints work for both Assertions and Expectations.

===== Verification over multiple Proxies

Lastly you can also verify multiple Proxies.
You will need a `Verifier` or a `NonfreezingVerifier` for that.
The difference between both will be explained with the notes to the Memory Model.
In order to apply Verification you can proceed as in the following example:

.Usage of multiple Proxies
[source,kotlin]
----
@Test
fun sampleTest() {
   val verifier = Verifier()
   val someInstance: SomeInterfaceMock = kmock(verifier = verifier)

   someInstance._someProperty.returns = "any"
   someInstance._someMethod.returns = "any"

   val someOtherInstance = SomeClass(someInstance)
   someOtherInstance.run()

   verifier.verifyOrder {
       ensureVerificationOf(someInstance) // optional

       someInstance._someProperty.wasGotten()
       someInstance._someMethod.hasBeenCalled()
       someInstance._someMethod.hasBeenCalled()
   }
}

----

Verification over multiple Proxies comes in 2 flavours - `verifyOrder` as seen above and `verifyStrictOrder`.
While `verifyOrder` allows gaps and does not need all captured invocations covered, `verifyStrictOrder` will fail if something is missing.
Both methods utilise the already explained Expectation Methods. +
Optionally you can use `ensureVerificationOf` if you need any insurance that all Proxies have been covered during a run by a Verifier. +
Both Verifiers can be initialised with the `coverAllInvocations` flag, which is `false` by default.
This flag forces Proxies, which are excluded from Verification via Verifier by default, to be covered during a test unit run too.
This is only important if you have to cover build-in methods like `equals`.
Build-in methods are excluded from Verification via Verifier by default due to their special nature.


==== Setup/Teardown Mocks

===== Setup (the kmock function)
As already shown in the examples above KMock comes with a factory method `kmock..
All Mocks are built with the same naming pattern (the name of the Interface and the suffix _Mock_), in the hope to ease referencing generated Mocks. +
`kmock` takes 4 arguments: `verifier`, `relaxed`, `relaxUnitFun` and `freeze`.
`relax` and `relaxUnitFun` determine if relaxing should be used and are false by default.
`freeze` determines which flavour for the Memory Model is used and is true by default. +
The last thing you need is to reference the type of the Mock.

NOTE: If your Interface is generic, `kmock` takes an additional argument called `templateType`.
This argument must be used to identify the right Mock and to avoid type collisions.
The parameter itself takes the `KClass` of the Interface which has been mocked.

Also it is highly encouraged to reuse Mocks, if possible, in a test suite by making them a member of the suite.
Your compile-time will profit from it! +
KMock will also allow you to use Interfaces as reference types for `kmock`.
In order to use that feature you need to set `allowInterfacesOnKmock` to `true`.
This is handy when used in tandem with Relaxation or by simply used as return value for stubbing.

===== Teardown
All Mocks are generated with a `_clearMock` method which clears all Proxies owned by the Mock.
This enables you to use Mocks per test suite, which is highly recommended, and not only per test case:

.Teardown Proxies
[source,kotlin]
----
@MockCommon(
   SampleInterface::class,
   ..
)
class SampleTestSet {
   private val someInstance: SomeInterfaceMock = kmock()

   @AfterTest
   fun tearDown() {
       someInstance._clearMock()
   }

   @Test
   fun sampleTest() {
       ..
   }

}
----

NOTE: Also Verifiers expose a `clear` method, so do not forget to call it as well if you use them!

==== Spying
KMock also supports Spying to a certain degree.
While you still need to instantiate the _subject to spy on_ (SO) by hand to avoid any funny behaviour and you may delegate the SO to `kspy` and voila habemus spy! +
However Spying is disabled by default.
To enable it you need to reference the Interface of the SO.
This is done by adding the full qualified name of the Interface to the `spyOn` field of KMock's Gradle Plugin Extension.
Also you must declare a Mock for that Interface as usual. +
If both preconditions are fulfilled, KMocks factory function `kspy` will recognize the Mock as able to utilise spies. +
`kspy` works similar to `kmock` and takes 3 arguments `spyOn`, `verifier` and `freeze`.
`spyOn` expects the SO and you need to reference the Mock Class. +


NOTE: If your interface is generic, `kspy` takes an additional argument called `templateType`.
This argument must be used to identify the right Mock and to avoid type collisions.
The parameter itself takes the `KClass` of the interface which has been mocked.

As with `kmock` you can enable interfaces as types for `kspy`.
This is meant for relaxing to ease the need to add boilerplate code if used in that context.
To enable interfaces you simply set `allowInterfacesOnKspy` of KMock's Gradle Plugin Extension to `true`.

Also you still can override specific methods or properties by using the corresponding Proxy Property.
In other words methods or properties of an SO are used instead of throwing an error, if no behaviour or stub was assigned to a Proxy, so it acts completely non intrusive.
The precedence described above stays otherwise untouched.

NOTE: Setters are always invoked.

If you are using spies be aware that build-in methods use the SO's methods here as well and are always present.
This might result in a behaviour which is not obvious right away:

.Example Spying on build-in methods
[source,kotlin]
----
@Test
fun sampleTest() {
   val subjectToSpyOn = AnyImplementation()
   val someInstance: SomeInterfaceMock = kspy(subjectToSpyOn)

   assertTrue((someInstance as Any) == someInstance) // will pass
   assertTrue((someInstance as Any) == subjectToSpyOn) // will pass
   assertTrue((subjectToSpyOn as Any) == someInstance) // will fail
}

----

While the first and second Assertion passes the 3rd won't.
So why is it that? +
KMock uses inheritance not reflection as you remember.
The 3rd assertion fails since `AnyImplementation` has no custom implementation of `equals` and uses the default.
If `AnyImplementation` makes a custom comparison with taking properties for example into account, the Assertion would pass.

Lastly there is another thing to know about Spies.
They come with a certain limitation.
If you use generics which are recursive and declared on function level like:

.Usage of multiple Proxies
[source,kotlin]
----
interface GenericThing {
   fun <T> doSomething(payload: T) where T : Comparable<T>
}


----

If `doSomething` is mocked and invoked it will result in an error.
This is simply due to the fact that technically Declarations like `fun <T> doSomething(payload: T) where T : SomeGeneric<String>, T : Comparable<List<Array<T>>>` legal, but won’t work and the compiler cries out.
So if `doSomething` would be mocked, the compiler will most likely point to generated Mock, which is actually not the cause of the problem, but the outcome.
However KMock cannot know which cases are right or wrong upfront, but it allows you to select them.
KMocks Gradle Plugin Extension has a property called `allowedRecursiveTypes`, where you can declare the cases where it actually should work.
`allowedRecursiveTypes` takes a set of the full qualified names of the recursive generics types (e.g. `kotlin.Comparable`).


==== Relaxation
Lastly, KMock also facilitates Relaxation to a certain degree and will hopefully get better over time.
As with spies it requires boilerplate code done by you. +
However, Relaxation of methods which return `Unit` is build-in feature, so do not worry about it.
You only need to switch `relaxUnitFun` to `true`. +
To get full Relaxation support you need to implement a relaxer function and annotate it properly:

.Relaxation function
[source,kotlin]
----
@Relaxer
internal inline fun <reified T> relax(id: String): T {
   return if (id.endsWith("#_find")) {
       Any()
   } else {
       throw RuntimeException()
   }
}

----

The annotation `@Relaxer` tells KMock that a Relaxer is present and is up for usage.
The Relaxer can be an arbitrary function but has to follow a specific signature, similar as shown above. +
The function can be either inline or not.
The type parameter can be either `reified` or not, but must be present and used as the return value.
There can be only one type parameter. +
The function can be marked as internal or not, but must be visible by the Mocks.
Also the function must take exactly one argument, which is a String.
This argument will be provided when invoked by a Proxy and is its id.
You may use it to differentiate between Proxies. +
At last you need to switch relaxing on by adding `relaxed = true` to `kmock`:

.Example Source up with Relaxation
[source, kotlin]
----
interface SampleDomainObject {
   fun resolve(): Any
}

interface SampleService {
   fun find(id: String): SampleDomainObject
}
----

.Example Relaxation function
[source, kotlin]
----
@Relaxer
internal inline fun <reified T> relax(id: String): T {
   return if (id.endsWith("#_find")) {
       kmock()
   } else {
       throw RuntimeException()
   }
}
----

.Example Test with Relaxation
[source, kotlin]
----
@MockCommon(
   SampleService::class,
   SampleDomainObject::class
   ..
)
class SampleTestSet {
   private val someInstance: SampleServiceMock = kmock(relaxed = true)

   @Test
   fun sampleTest() {
       assertTrue(someInstance.find("somthing") is SampleDomainObject)
   }
}
----

IMPORTANT: Only one Relaxer can be defined per project!

As with spies you still can override specific methods by using the corresponding Proxy Property.
In other words Relaxation is used instead of throwing an error, if no behaviour was assigned to a Proxy and makes Mock non intrusive.
The precedence described above stays otherwise untouched.

NOTE: Relaxation will not work with build-in methods like `hashCode`.
Those methods excluded from Relaxation and fall back to their parent.

==== Memory Model
KMock still uses Kotlin's ‘old’ Memory Model.
Therefore you might run into some trouble in certain cases. +
Both factory functions - `kmock` and `kspy` - take an argument `freeze` which is true by default.
This means everything which is delegated to an Proxy (including Relaxation) or Verifier must conform with the freezing Memory Model of Kotlin. +
By switching `freeze` to `false` it changes the flavour to non-freezing.
If you use non freezing Mocks, make sure you use the corresponding Verifier (`NonfreezingVerifier`) and all interacting Mocks are non-freezing as well. +
This is inconvenient for now but will go away once the new Memory Model is more stable.

==== Customization
===== ArgumentConstraints
KMock is capable of using your custom defined ArgumentConstraints.
You can simply extend `ArgumentConstraint` of the `KMockContract` and implement the functionality you require and use it. Done!

===== Assertions
You are also able to to write your custom Assertions by implementing a custom link:https://kotlinlang.org/docs/extensions.html[extension function] for either the `Proxy`, `FunProxy`, `PropertyProxy`, `SyncFunProxy` or `AsyncFunProxy` Interface of the `KMockContract`. +
KMock exposes 4 functions which are intended for this purpose.
`getArgumentsByType`, `getAllArgumentsByType` and `getAllArgumentsBoxedByType` working only for FunProxies, while `getArgumentsForCall` works for all Proxy types.
`getArgumentsByType` can be used to retrieve Arguments for a specific call and type, `getAllArgumentsByType` and `getAllArgumentsBoxedByType` collecting over all invocations.
The main difference between the latter methods is simply that `getAllArgumentsByType` will collect arguments in a linear order,
while `getAllArgumentsBoxedByType` will box them in a List per call.
Use those methods with caution, since they are likely subject to changes, once the concept of assertions gets a second look. +
KMock itself uses `getArgumentsForCall` which you might wanna use as well while working with PropertyProxies or you need a type unaware method to extract arguments from Proxies.

Happy coding!
