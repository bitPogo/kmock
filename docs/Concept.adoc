= KMock
:link-base: https://github.com/bitPogo
:link-repository: {link-base}/kmock
:link-docs: {link-repository}/tree/main/docs
:link-api: {link-docs}/api
:doctype: article
:author: Matthias Geisler
:revnumber: 1.0
:project-version: 0.1.0
:toc: macro
:toclevels: 3
:toc-title:
:icons: font
:imagesdir: assets/images
:lang: en
ifdef::env-github[]
:warning-caption: :warning:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
endif::[]

[discrete]
== Table Of Contents

toc::[]

== Motivation and Goals

Writing mocks is certainly no witchcraft, but doing them by hand day for day can be dull.
While KMP has come to stay, there was no candidate, which fills the gap in terms of mocking satisfactory.
Moreover, already existing libraries could not handle all basic test scenarios I encountered nor were able to fly out of the box.+
Well, complaining is easy, so I started to get my hands dirty, embarked on a mission to change that and KMock was born. +
It should at least fulfil the following properties:

* easy to set up,
* easy to work with,
* customizable,
* working for shared and platform sources alike,
* working on any platform in the very same way,
* easy to maintain with a minimum amount of effort.

== Approach
KMock works on the same foundation as other mock libraries for KMP and can only utilise Interfaces to generate Mocks.
link:https://github.com/google/ksp[Kotlin Symbol Processing (KSP)] makes that possible.
It can be completely non intrusive, if it is set up that way.
This means if you use for example relaxation, generated mocks can run without any further information. +
What makes KMock different though is that it uses a different mind-model than most other mock libraries.
While most popular libraries are based on a record-replay(-verify) pattern, KMock borrowed from Python’s link:https://docs.python.org/3/library/unittest.mock.html[MagicMock], which falls more in line to the link:https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests[arrange-act-assert (AAA)] pattern.
Well, in KMock’s case it is more of an arrange-act-assertOrVerify pattern at the moment.
AAA gives KMock the possibility to function as link:https://www.martinfowler.com/articles/mocksArentStubs.html[mocks or stubs] alike, since you are assigning behaviour or a canned return value:

.KMock example
[source,kotlin]
----
@Test
fun sampleTest() {
    // arrange
    val someInstance: SomeInterface = kmock()

    someInstance._someProperty.returns = "any"
    someInstance._someMethod.returns = "any"

    // act
    val someOtherInstance = SomeClass(someInstance)
    someOtherInstance.run()

    // assert
    someInstance._someProperty.assertWasGotten(exactly = 1)
    someInstance._someMethod.assertWasCalled(exactly = 1)
}
----

KMock realises the AAA by adding doubles of any member of an interface it encounters.
Those Proxies contain then the bulk of the logic you actually use. +
A 2nd noteworthy side effect due to this approach is that most functionality is directly bound to the generated Mocks, so things will just pop up in your IDE or Editor and this hopefully flattens the learning curve. +
KMock features operate on demand.
For example if you want to spy on a specific interface, you have to enable it.
This is primarily done to not waste compile-time on stuff which is actually not needed, but not to forgo features at the same time which might be handy in certain cases or accommodate certain testing styles.
But be aware, you have to pay a price for it if you enable something, even if we speak about milliseconds or seconds here. +
Lastly you do not need to care a lot about asynchronous or synchronous execution - it goes through the same API.


== Trade Offs
While this might sound this far appealing, KMock has its flaws.
Names of Proxies can look very weird in the first moment, since KMock uses the types of the member it doubles to avoid collision. +
Also anything KMock does is an overhead to your code, but consider the fact you would have done that most likely by hand.
In order to measure that in time I put up a small link:{link-base}/kmock-benchmark[Benchmark-Project], which is free to use as well. +
This project consists of 50 interfaces with 5 methods each and one test suite to run the resulting mocks.
Additionally it sets up link:https://github.com/Kodein-Framework/MocKMP[MocKMP] and link:https://github.com/mockative/mockative[Mockative] to have a reference point. +
I measured JVM, JS and iOSX64 as a reference-platform for native.
Also I checked only the time the test suite takes after the project was cleaned, which means in the day-to-day any library will be faster.
Lastly only the median of KSP and how long it takes from the start of compiling to start the first tests had been of interest for me. +
The fasted library on all platforms was MocKMP (JVM: 4.2 sec, Js: 7.7 sec, iOS: 17 sec), which is honestly not a big surprise, since it generates the lightest Mocks by far. +
Mockative is the hero when it comes to KSP and out runs all other libraries (JVM: 390 ms, iOS: 420 ms).
Overall it is not the fastest, since the compiler has to do slightly more.
This brings it on JVM to 6.4 sec and iOS to 19 sec. +
So what is with KMock?
Well, it depends how much you enable. Once I had the first numbers I started to hide features behind flags, since they impacted the compile time needlessly.
To get an impression, if you enable spies for all interfaces it adds ~2 sec to the compile time of JVM and ~4 sec of iOS. +
Also to keep it comparable I will speak here about the lightest configuration of KMock, since it covers the same functionality as MocKMP and Mockative.
What is really surprising, KSP runs slightly faster compared to MocKMP (JVM ~100 ms, Js: ~110 ms, iOS: ~50 ms), even though KMocks Processor is much bigger than MocKMPs.
In terms of compile time it is unfortunately slower.
Overall it takes 6 sec to run KSP and the compiler for JVM, 8.5 sec for Js and 21 sec for iOS.
However the greatest choke points of KMock are its factories and for native the proxy members of the Mocks ship into it additionally.
But you pay for convenience.


== What’s next?
There are already ideas how to gain the superpower of mock or stub classes, objects or static accessories in KMock, but this will need some time and effort to realise.
While waiting for bugreports and making some minor improvements the next bigger step will most likely to give Assertion a more deeper thought and to decide if Verification or Assertion fits better into KMock.
Also adding an optional package to ease relaxing is likely. +
Lastly more ArgumentConstraints will be added to improve their usability. +
So stay tuned and if you miss something, feel welcome to open an issue.
