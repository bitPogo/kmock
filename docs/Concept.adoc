= KMock
:link-base: https://github.com/bitPogo
:link-repository: {link-base}/kmock
:link-docs: {link-repository}/tree/main/docs
:link-api: {link-docs}/api
:doctype: article
:author: Matthias Geisler
:revnumber: 1.0
:project-version: 0.1.0
:toc: macro
:toclevels: 3
:toc-title:
:icons: font
:imagesdir: assets/images
:lang: en
ifdef::env-github[]
:warning-caption: :warning:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
endif::[]

[discrete]
== Table Of Contents

toc::[]

== Motivation and Goals

Writing a mock library for a certain platform can be hard enough, but Kotlin Multiplatform takes that task to a new level.
Especially the Kotlin's current Memory Model does not make the job easier. +
One noticeable early attempt to overcome those obstacles was link:https://github.com/touchlab/Karmok[Karmock], which regrettably never made it out of its pre alpha stage.
Since the introduction of link:https://github.com/google/ksp[Kotlin Symbol Processing (KSP)] there is new hope to address the problem (at least partially)! +
Already 2 other libraries also strive to overcome this - link:https://github.com/mockative/mockative[mockactive] and link:https://github.com/Kodein-Framework/MocKMP[MocKMP].
Both did a remarkable job without any doubt (so you might wanna check them out) and served as inspiration! +
However they did not offer the full extent of convenient and functionality I had in mind.
For me such a library should be:

* as easy as possible to setup without extensive configuration,
* run on any shared source or platform source alike,
* easy to maintain/change/test in order to provide stability,
* reduce boilerplate code,
* customizable to most possible and reasonable extend,
* allowing concepts like spying or relaxing,
* as easy as possible to use with a minimum set of instructions.

In other words mocking tests should work without shenanigans or frills.

=== Concept

What makes KMock different form others is mainly its mindmodel.
link:https://mockk.io/[MockK] for example uses the classical _record-replay-verify_ pattern, while KMock borrowed from Python's link:https://docs.python.org/3/library/unittest.mock.html[MagicMock].
MagicMock follows _arrange-act-assert_ (aka 3A or AAA), which KMock follows too. +
To compare both: +

.MockK example
[source,kotlin]
----
@Test
fun sampleTest() {
    // record
    val someInstance: SomeInterface = mockk()

    every { someInstance.someProperty } returns "any"
    every { someInstance.someMethod(any(), any()) } returns "any"

    // replay
    val someOtherInstance = SomeClass(someInstance)
    someOtherInstance.run()

    // verify
    verify(exactly = 1) { someInstance.someProperty }
    verify(exactly = 1) { someInstance.someMethod(any(), any()) }
}
----

The same could be written as: +

.KMock example
[source,kotlin]
----
@Test
fun sampleTest() {
    // arrange
    val someInstance: SomeInterface = kmock()

    someInstance._someProperty.returns = "any"
    someInstance._someMethod.returns = "any"

    // act
    val someOtherInstance = SomeClass(someInstance)
    someOtherInstance.run()

    // assert
    someInstance._someProperty.assertWasGotten(exactly = 1)
    someInstance._someMethod.assertWasCalled(exactly = 1)
}
----

As you can see above KMock attaches Proxy Properties, which are simply assigned. +
This implies all necessary information are available at compile time and are not resolved during runtime.
KMock uses link:https://github.com/google/ksp[KSP] to achieve that and is currently restricted to *Interfaces only*. +
The main benefit of this mindmodel is the reduction of knowledge you need to acquire upfront.
Your IDE or Editor will help you with that due to the power of autocompletion. +
Also you do not have to care if a method is asynchronous or synchronous while interacting with them - both goes through the same API.
If you want to try it out directly please checkout the link:{link-base}/kmock-playground[Playground].
If you want learn more about the concrete usage, please continue reading in the link:StarterGuide.adoc[Starter Guide].

=== Main Components

KMock consists of 3 main components - its runtime library, its KSP Processor and its Gradle Plugin.
The runtime library brings in the main functionality, like Verification or Proxies. +
The Processor resolves all annotated Interfaces and writes all necessary Mocks. +
Lastly the Gradle Plugin takes care of moving the generated Mocks to the right place and makes them available to the source sets.
This Plugin is mainly necessary since KSP cannot differentiate between shared sources like commonTest or iosTest by its own.
See link:https://github.com/google/ksp/issues/567[here] for more.

=== What's next

KMock is still in its infants, which means there is still work to do around its core concepts and implementation.
Also due to nature of KMP it needs a deeper evaluation especially in regards to the impact of compile time.
This certainly influences the development experience and must be the main criteria to determine if and how to go on from here. +
However besides those question the next possible steps are most likely:

* allow mocking of classes,
* reduce needed boilerplate code for relaxation.

And if you miss anything open an issue and let me know!
