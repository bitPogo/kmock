{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KMock","text":"<p>A humble mocking library for Kotlin, KotlinJS and Kotlin Multiplatform using Kotlin Symbol Processing (KSP).</p> <p> </p>"},{"location":"#about-the-project","title":"About The Project","text":"<p>Writing mocks is certainly no witchcraft, but doing them by hand day for day can be dull. More importantly it takes time which can be better invested directly into writing tests. However, while JVM projects get indeed supreme support by either MockK or Mockito, Kotlin Multiplatform still has nothing comparable. KMock aims to fill that gap and will hopefully advance to there over time. Similar to other projects it uses KSP, but it is capable of associating generated Mocks correctly to their belonging shared source sets (like native, ios, etc) without additional setup and with minimal boilerplate done by consumers. KMock works currently only based on interfaces. It supports to some extent features like spying and relaxation of Mocks to make them non intrusive. So if the project caught your eye check out the Playground or dive into the Documentation.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>KMock has the following dependencies:</p> <ul> <li>AndroidGradlePlugin (AGP) 7.3.1</li> <li>Kotlin 1.8.0</li> <li>AtomicFu 0.19.0</li> <li>Touchlab's Stately 1.2.3</li> <li>Square KotlinPoet 1.12.0</li> <li>Kotlin Symbol Processing (KSP) 1.8.0-1.0.8</li> <li>Gradle 7.5.1</li> </ul>"},{"location":"#additional-requirements","title":"Additional Requirements","text":"<ul> <li>Android 5.0 (API 21) to Android 13 (API 33)</li> <li>Java 11</li> </ul>"},{"location":"#changelog","title":"Changelog","text":"<p>See changelog.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>This project uses Semantic Versioning as a guideline for our versioning.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>You want to help or share a proposal? You have a specific problem? Read the following:</p> <ul> <li>Code of Conduct for details on our code of conduct.</li> <li>Contribution Guide for details about how to report bugs and propose features.</li> </ul>"},{"location":"#releasing","title":"Releasing","text":"<p>Please take a look here.</p>"},{"location":"#copyright-and-license","title":"Copyright and License","text":"<p>Copyright \u00a9 2024 Matthias Geisler / All rights reserved.</p> <p>Please refer to the License for further details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All important changes of this project must be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#deprecated","title":"Deprecated","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Deprecated targets</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#security","title":"Security","text":""},{"location":"changelog/#bumped","title":"Bumped","text":"<ul> <li>Gradle 7.5.1 -&gt; 8.6.0</li> <li>Android Gradle Plugin 7.3.1 -&gt; 8.2.2</li> <li>Kotlin 1.8.0 -&gt; 1.9.22</li> <li>KSP  1.8.0-1.0.8 -&gt; 1.9.22-1.0.17</li> <li>AtomicFu 0.19.0 -&gt; 0.23.2</li> <li>Stately 1.2.3 -&gt; 2.0.6</li> <li>Android Target SDK 32 -&gt; 34</li> <li>CompilerTest 1.4.9 -&gt; 0.4.0 (ZacSweers)</li> <li>min Java 11 -&gt; 17</li> </ul>"},{"location":"changelog/#v030-rc08","title":"v0.3.0-rc08","text":""},{"location":"changelog/#bumped_1","title":"Bumped","text":"<ul> <li>Kotlin 1.7.22 -&gt; 1.8.0</li> <li>AtomicFU 0.18.5 -&gt; 0.19.0</li> <li>KSP 1.7.22-1.0.8 -&gt; 1.8.0-1.0.8</li> </ul>"},{"location":"changelog/#v030-rc07","title":"v0.3.0-rc07","text":""},{"location":"changelog/#bumped_2","title":"Bumped","text":"<ul> <li>Kotlin 1.7.21 -&gt; 1.7.22</li> <li>KSP 1.7.21-1.0.6 -&gt; 1.7.22-1.0.8</li> </ul>"},{"location":"changelog/#v030-rc06","title":"v0.3.0-rc06","text":""},{"location":"changelog/#bumped_3","title":"Bumped","text":"<ul> <li>Kotlin 1.7.20 -&gt; 1.7.21</li> <li>KSP 1.7.20-1.0.6 -&gt; 1.7.21-1.0.8</li> </ul>"},{"location":"changelog/#v030-rc05","title":"v0.3.0-rc05","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>support for Kotlin Apple Targets and mingwX64</li> </ul>"},{"location":"changelog/#bumped_4","title":"Bumped","text":"<ul> <li>Kotlin 1.7.10 -&gt; 1.7.20</li> <li>AtomicFu 0.18.3 -&gt; 0.18.5</li> <li>KSP 1.7.10-1.0.6 -&gt; 1.7.20-1.0.6</li> <li>Android Gradle Plugin 7.3.0 -&gt; 7.3.1</li> </ul>"},{"location":"changelog/#030-rc04","title":"0.3.0-rc04","text":""},{"location":"changelog/#bumped_5","title":"Bumped","text":"<ul> <li>Gradle 7.5 -&gt; 7.5.1</li> <li>Kotlin 1.7.0 -&gt; 1.7.10</li> <li>AtomicFu 0.18.2 -&gt; 0.18.3</li> <li>Android Target SDK 32 -&gt; 33</li> <li>KSP 1.7.0-1.0.6 -&gt; 1.7.10-1.0.6</li> <li>Android Gradle Plugin 7.2.1 -&gt; 7.3.0</li> </ul>"},{"location":"changelog/#030-rc03","title":"0.3.0-rc03","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>pseudo build-in methods are now resolved independently</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Aliases as type arguments are not correctly resolved, if the Aliases have type arguments on their own</li> <li>Generics cause AccessMethods to collide in their definition</li> <li>Stackoverflow when determine TypeVariance</li> <li>Unrelated MetaSources caused NPE</li> </ul>"},{"location":"changelog/#bumped_6","title":"Bumped","text":"<ul> <li>Gradle 7.4.2 -&gt; 7.5</li> <li>Kotlin 1.6.21 -&gt; 1.7.0</li> <li>KotlinPoet 1.11.0 -&gt; 1.12.0</li> <li>AtomicFu 0.17.3 -&gt; 0.18.2</li> <li>Stately 1.2.1 -&gt; 1.2.3</li> <li>Android Target SDK 31 -&gt; 32</li> <li>CompilerTest 1.4.8 -&gt; 1.4.9</li> </ul>"},{"location":"changelog/#030-rc02","title":"0.3.0-rc02","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>sources for <code>release</code> and <code>debug</code> for non KMP are now added via the Android extension while custom build-variant need manual setup</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Build Cache enabled, Mocks are not created</li> <li>Relaxer not picked correctly up on multiple test runs</li> <li>Multi Interface Cleanup causes compilation to fail</li> </ul>"},{"location":"changelog/#bumped_7","title":"Bumped","text":"<ul> <li>Android Target SDK 31 -&gt; 32</li> </ul>"},{"location":"changelog/#030-rc01","title":"0.3.0-rc01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>preventResolvingOfAliases</code> as workaround for AccessMethods with expect/actual Aliases which cause incremental builds to fail</li> </ul>"},{"location":"changelog/#bumped_8","title":"Bumped","text":"<ul> <li>Kotlin 1.6.10 -&gt; 1.6.21</li> <li>AtomicFu 0.17.1 -&gt; 0.17.3</li> <li>KSP 1.6.10-1.0.4 -&gt; 1.6.21-1.0.6</li> </ul>"},{"location":"changelog/#022","title":"0.2.2","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li><code>run</code>/<code>runs</code> does not trigger SideEffect invocation</li> </ul>"},{"location":"changelog/#021","title":"0.2.1","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Plugin triggered the usage of the legacy JS compiler for KotlinJs</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>and</code> ArgumentConstraint</li> <li><code>getValue</code> which preserves the old behaviour of get (PropertyProxy)</li> <li><code>getValues</code> to replace getMany (PropertyProxy)</li> <li><code>error</code> to replace throws (FunProxy)</li> <li><code>errors</code> to replace throwsMany (FunProxy)</li> <li><code>returns</code> which acts as setter for <code>getValue</code>/<code>returnValue</code> for Proxies</li> <li><code>returnsMany</code> which acts as setter for <code>getValues</code>/<code>returnValues</code> for Proxies</li> <li><code>throws</code> (infix method) which acts as setter for <code>error</code> for FunProxies</li> <li><code>throwsMany</code> (infix method) which acts as setter for <code>errors</code> for FunProxies</li> <li><code>runOnGet</code> which acts as setter for <code>getSideEffect</code> for PropertyProxies</li> <li><code>runOnSet</code> which acts as setter for <code>setSideEffect</code> for PropertyProxies</li> <li><code>hasNoFurtherInvocations</code> to ease <code>assertProxy</code></li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>The plugin can now applied directly while configuration must be done after the <code>kotlin</code> setup</li> <li>AccessMethods need always a hint if the Template has type parameters</li> <li>ProxyNameResolver is capable of utilizing the actual types of generic parameters when overloaded</li> <li><code>run</code>/<code>runs</code> are now infix methods</li> <li>Proxies have now an operator for get which means they can be accessed like Arrays</li> <li>BREAKING <code>get</code> is now responsible for the SideEffect of PropertyProxies</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li><code>getMany</code> (PropertyProxy)</li> <li><code>throws</code> (FunProxy)</li> <li><code>throwsMany</code> (FunProxy)</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>BREAKING <code>getSideEffect</code> (PropertyProxy)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li><code>vararg</code> eats specialised Array Types (e.g. IntArray) and covariant types when inherited</li> <li>Factories for Multi-Interface-Mocks</li> <li>Multi-Boundary Parameter are not right resolved when mixed multi with regular parameter in nested types</li> <li>Collisions of type aliases with regular method signatures</li> </ul>"},{"location":"changelog/#020-rc01","title":"0.2.0-rc01","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li><code>or</code> ArgumentConstraint</li> <li><code>not</code> ArgumentConstraint</li> <li><code>spiesOnly</code> in the Gradle extension, in order to tell the processor to only create <code>kspy</code>. Also <code>spyOn</code> is not needed in this configuration</li> <li><code>spyAll</code> in the Gradle extension, in order to tell the processor to create for al given interfaces also a spy entryPoint</li> <li><code>vararg</code> is now supported by Mocks</li> <li><code>freezeOnDefault</code> in the Gradle extension, which sets a default freeze value for <code>kspy</code> and <code>kmock</code></li> <li><code>useTypePrefixFor</code> for overloaded names in order to ease them and avoid collisions</li> <li><code>customMethodNames</code> in order to allow complete custom names for methods</li> <li><code>allowInterfaces</code>, which combines <code>allowInterfacesOnKmock</code> and <code>allowInterfacesOnKspy</code></li> <li><code>disableFactories</code> in order to disable the generation of <code>kmock</code> and <code>kspy</code> if needed</li> <li><code>customAnnotationsForMeta</code> to provide a hook for the usage of customized annotation for meta/shared sources</li> <li><code>assertOrder</code> in order to make the names more consistent and preserves the old behaviour of <code>verifyStrictOrder</code></li> <li><code>assertProxy</code> as alternative to <code>verify</code></li> <li>iosSimulatorArm64 support</li> <li>Support for instrumented Android tests (aka androidAndroidTest) on KMP</li> <li>Multi-Interface Mocks support</li> <li>Interface receiver members are full supported</li> <li><code>run</code> for FunProxies to mitigate the strict assignment policy in terms of a single SideEffect</li> <li><code>runs</code> for FunProxies to mitigate the strict assignment policy in terms of SideEffects</li> <li><code>throwsMany</code> for FunProxies to align the the FunProxy API</li> <li><code>enableFineGrainedNames</code> in order to allow fine grained typing (experimental/not this will feature helps you only in a non JVM context)</li> <li><code>KMock</code> experimental annotation, which is agnostic in terms of source sets</li> <li><code>KMockMulti</code> experimental annotation, which is agnostic in terms of source sets</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Generated mocks don't contain runtime logic any longer</li> <li>Mutable properties of Proxies now separate froze/unfrozen state is cleaner to improve Runtime</li> <li><code>kmock</code> and <code>kspy</code> are using now a shared function to improve compile time</li> <li>Non intrusive behaviour (spy &amp; relaxation) is now resolved by proxy invocation rather then by proxy initialisation in order to cover edge cases</li> <li>Assertion-/VerificationChain is not coupled any longer directly to proxies and provide improved error messages</li> <li>Expectation Methods do not bleed into the global context any longer</li> <li><code>verifyStrictOrder</code> is now used for total order of certain Proxies but allows partial order between different Proxies</li> <li>Android MinSDK 23 -&gt; 21</li> <li><code>spyOn</code> is now capable of picking up KMock defined Aliases</li> <li><code>kspy</code> in terms of generics not longer exposed if not declared via <code>spyOn</code> or <code>spiesOnly</code></li> <li>Relaxation method gets now the return type boundaries delegated, if generic in order to resolve type conflicts</li> <li>Generic methods names get prefixed by the generic type name, if it is overloaded to avoid name collisions</li> <li>Generic methods names get prefixed by an indicator, if it is overloaded and nullable to avoid name collisions</li> <li>Meta/Shared Source Annotation are now supporting platform references (e.g. instead of metaTest you can write meta)</li> <li>Custom Source Annotation are now supporting platform references (e.g. instead of sharedTest you can write shared)</li> <li>Proxy-Access-Methods and their corresponding verification/assertion counter parts</li> <li><code>verifer</code> argument is now called <code>collector</code> in <code>kmock</code> and <code>kspy</code></li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li><code>allowedRecursiveTypes</code>, since it is no longer needed due to the new spy invocation</li> <li><code>allowInterfacesOnKmock</code>, use allowInterfaces instead</li> <li><code>allowInterfacesOnKspy</code>, use allowInterfaces instead</li> <li>Old experimental ProxyAssertion family, use <code>assertProxy</code> or <code>verify</code> instead</li> <li><code>uselessPrefixes</code> in the Gradle Extension</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>FunProxy names with nullable or multi-bounded types defined as generic parameter</li> <li>Annotation was not picked up when more then one Annotation was used</li> <li>Factories for Common were not created when no Template was specified</li> <li>Parallel declared shared source were eaten up by each other</li> <li>Nested Generic Types were not resolved for Proxies</li> <li>Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable</li> </ul>"},{"location":"changelog/#bumped_9","title":"Bumped","text":"<ul> <li>KotlinPoet 1.10.2 -&gt; 1.11.0</li> <li>Gradle 7.4.1 -&gt; 7.4.2</li> <li>Android Gradle Plugin 7.1.2 -&gt; 7.2.1</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Warnings for unused expression and unused parameter in MockFactory</li> </ul>"},{"location":"changelog/#bumped_10","title":"Bumped","text":"<ul> <li>Gradle 7.2 -&gt; 7.4.1</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Initial release.</p>"},{"location":"concept/","title":"Concept","text":"<p>Writing mocks is no witchcraft, but doing them by hand day for day can be dull. While KMP has come to stay it still lacks a mock library which can deal well with KMPs language features satisfactorily. Well complaining is easy and \"how hard can it\"\u2122 be to create such a library? Hence, KMock was born.</p>"},{"location":"concept/#approach","title":"Approach","text":"<p>As other existing KMP mock libraries, KMock utilizes the power of Kotlin Symbol Processing (KSP) and generates mocks based on interfaces. Well, actually, in a strict sense, KMock generates stubs or fakes to a certain degree.</p> <p>It draws its biggest inspiration from Python\u2019s MagicMock in terms of the API, since it is easy to work with and offers conceptually a way to deal with the nature of KMP. While some mocking libraries depend on record-replay-verify pattern, KMock does not. It's mind model blends more into the arrange-act-assert pattern (AAA). For example while you write in mockk: <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SomeInterface = mockk()\n\n    // record\n    every { someInstance.someProperty } returns  \"any\"\n    every { someInstance.someMethod(any(), any()) } returns  \"any\"\n\n    // act\n    val someOtherInstance = SomeClass(someInstance)\n    someOtherInstance.run()\n\n    // assert\n    verify(exactly = 1) { someInstance.someProperty }\n    verify(exactly = 1) { someInstance.someMethod(any(), any()) }\n}\n</code></pre> You'll write in KMock: <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SomeInterfaceMock = kmock()\n\n    someInstance._someProperty.getValue = \"any\"\n    someInstance._someMethod.returnValue  = \"any\"\n\n    // act\n    val someOtherInstance = SomeClass(someInstance)\n    someOtherInstance.run()\n\n    // assert\n    assertProxy {\n        someInstance._someProperty.wasGotten()\n        someInstance._someMethod.hasBeenCalledWith(any(), any())\n    }\n}\n</code></pre> In fact KMock will proxy each public member of a given interface instead of proxy the entire interface at once. This also allows for less intrusive behaviour than traditional mocking libraries.</p> <p>A second noteworthy side effect due to this approach is that most functionality is directly bound to the generated Mocks, so things will just pop up in your IDE or Editor. This hopefully flattens the learning curve too. Lastly it allows to minimize any ambiguity in terms of overloading or eases the work with receivers, which are runtime based libraries mostly struggle with.</p> <p>Another ingredient of KMock is that the library should do the heavy lifting as much as possible. This means a consumer should not have to engage in complicated configuration to make it work with KMP.</p> <p>Ideally it should just work, while supporting different tests and code styles. Therefore KMock implements a basic support for Relaxation or Spying. Also most features operate on demand and can be turned on/off.</p> <p>But each luck has its price\u2026</p>"},{"location":"concept/#trade-offs","title":"Trade Offs","text":"<p>While it so far it all sounds appealing, KMock of course has its conceptual trade offs. First and foremost compile time - while other libraries will try to resolve mostly everything at runtime, KMock will distribute things between compile- and runtime. This naturally means compiling will need more time, even if we speak about seconds here. Even though KMock is not optimized yet, it will most likely never be completely able to go toe to toe with pure runtime libraries. But you pay for accuracy and convenience.</p> <p>Also direct proxy access is not robust against refactoring since the generated names are detached from the interface it is based on. This goes especially for overloaded names and it bring its own batch of ugliness. While this a major drawback, KMock has experimental features to address these issues. Even though they are not completely matured yet and cannot be used for all use cases, they hopefully tackle these problems.</p>"},{"location":"concept/#what-is-the-overall-goal","title":"What is the overall goal?","text":"<p>Aside from the roadmap, KMock 's main aim is to make your life easier as much as possible. It will offer at some point in the future a proof of concept how implementation can be mocked, while it most likely never makes it into the main branch.</p>"},{"location":"license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"migration/","title":"Migration Guide","text":"<p>Apologies! Something was broken to improve KMock. But don't panic!</p>"},{"location":"migration/#020-rc01-to-020","title":"0.2.0-rc01 to 0.2.0","text":""},{"location":"migration/#behaviour-changes","title":"Behaviour Changes","text":"<ul> <li>The <code>get</code> property of PropertyProxy is now responsible for the SideEffect. This was done to get a more coherent API for this proxy type. <code>getValue</code> takes over for <code>get</code> to hold simple values.</li> </ul>"},{"location":"migration/#removed","title":"Removed","text":"<ul> <li>Replace <code>getSideEffect</code> with <code>get</code>.</li> </ul>"},{"location":"migration/#011-to-020-rc01","title":"0.1.1 to 0.2.0-rc01","text":""},{"location":"migration/#api-changes","title":"API changes","text":""},{"location":"migration/#names","title":"Names","text":"<ul> <li>FunProxy names with nullable or Multi-Bounded types defined as generic parameter - this may break some Proxies if they are referring to overloaded methods.</li> <li>Multi-Bounded Generics caused invalid Proxy name if overloaded and a leading boundary was nullable - this may break some Proxies if they are referring to overloaded methods.</li> <li>The <code>verifier</code> argument of factories is now called <code>collector</code>.</li> <li><code>NonfreezingVerifier</code> is now <code>NonFreezingVerifier</code>.</li> <li><code>verifyStrictOrder</code> is now <code>assertOrder</code>.</li> </ul>"},{"location":"migration/#removed_1","title":"Removed","text":"<ul> <li><code>allowedRecursiveTypes</code> - this option is obsolete and would have no effect.</li> <li><code>allowInterfacesOnKmock</code> - this option is obsolete and would lead to undesired behaviour, but you can use <code>allowInterfaces</code> instead.</li> <li><code>allowInterfacesOnKspy</code> - this option is obsolete and would lead to undesired behaviour, but you can use <code>allowInterfaces</code> instead.</li> <li>The experimental ProxyAssertion family - those methods were only aliases for <code>verify(exacty = 1) { ... }</code>. Please consider <code>assertProxy</code> or <code>verify</code> instead.</li> <li><code>uselessPrefixes</code> in the Gradle Extension - this option is obsolete and would have no effect.</li> </ul>"},{"location":"migration/#changed","title":"Changed","text":"<ul> <li>Expectation Methods do not bleed into the global context any longer. This means the imports of the old extensions must be removed and it they will work again.</li> </ul>"},{"location":"migration/#behaviour-changes_1","title":"Behaviour Changes","text":"<ul> <li><code>verifyStrictOrder</code> is now used for total order of certain Proxies but allows partial order between different Proxies, use <code>assertOrder</code> instead.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install","title":"Install","text":"<p>In your buildSrc/build.gradle.kts: <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"tech.antibytes.kmock:kmock-gradle:$KMockVersion\")\n}\n</code></pre></p> <p>In your root project build.gradle.kts: <pre><code>allprojects {\n    ...\n    repositories {\n        ...\n        mavenCentral()\n    }\n}\n</code></pre></p>"},{"location":"quickstart/#setup","title":"Setup","text":"<pre><code>import tech.antibytes.gradle.kmock.KMockExtension\n...\n\nplugins {\n    ...\n\n    id(\"tech.antibytes.kmock.kmock-gradle\")\n}\n\nkotlin {\n    ...\n\n    sourceSets {\n        ...\n        val commonTest by getting {\n            dependencies {\n                ...\n                implementation(\"tech.antibytes.kmock:kmock:$KMockVersion\")\n                ...\n            }\n        }\n        ...\n    }\n    ...\n}\n\nkmock {\n    rootPackage = \"my.root.package\"\n}\n</code></pre>"},{"location":"quickstart/#generate-a-mock","title":"Generate a Mock","text":"<pre><code>import tech.antibytes.kmock.MockCommon\n\n@MockCommon(\n   SampleInterface::class,\n   OtherSampleInterface::class,\n   ...\n)\nclass SampleTestSet {\n   ...\n}\n</code></pre>"},{"location":"quickstart/#use-your-mocks","title":"Use your Mocks","text":"<pre><code>...\n@Test\nfun sampleTest() {\n   // arrange\n   val someInstance: OtherSampleInterfaceMock = kmock()\n\n   someInstance._fetch.returnValue = Any()\n   someInstance._find returns \"any\"\n\n   // act\n   val someOtherInstance = SomeClass(someInstance)\n   someOtherInstance.run()\n   ...\n}\n...\n</code></pre>"},{"location":"quickstart/#verifyassert","title":"Verify/Assert","text":"<pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val asserter = Asserter()\n    val someInstance: SomeInterfaceMock = kmock(collector = asserter)\n    val someInstanceOther: SomeInterfaceMock = kmock(collector = asserter)\n\n   ...\n    // assert\n    asserter.verifOrder {\n       someInstance._someProperty.wasGotten()\n       someInstanceOther._someMethod.hasBeenCalled()\n       someInstance._someMethod.hasBeenCalled()\n   }\n}\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#030","title":"0.3.0","text":"<ul> <li>optimize &amp; stabilize proxy access methods</li> <li>stabilize agnostic annotations</li> <li>improve support for Android \u2705</li> <li>prototype class mocking for JVM based sources sets</li> <li>support more platforms \u2705</li> </ul>"},{"location":"roadmap/#020","title":"0.2.0","text":"<ul> <li>stabilize of the mock generation in respect of base use-cases \u2705\ufe0f</li> <li>support varargs \u2705\ufe0f</li> <li>support receivers \u2705\ufe0f</li> <li>support custom annotations \u2705\ufe0f</li> <li>support mocks based on multiple interfaces \u2705\ufe0f</li> <li>stabilize verification/assertion \u2705\ufe0f</li> <li>stabilize proxy api \u2705\ufe0f</li> <li>introduce a more robust way to access proxies \u2705\ufe0f</li> <li>prototype an agnostic annotation for arbitrary sources \u2705\ufe0f</li> <li>publish to MavenCentral \u2705\ufe0f</li> </ul>"},{"location":"roadmap/#010","title":"0.1.0","text":"<ul> <li>support hierarchical source sets \u2705</li> <li>support properties \u2705</li> <li>support methods \u2705</li> <li>support overloading \u2705</li> <li>support generics \u2705</li> <li>support spies \u2705</li> <li>support relaxation \u2705</li> <li>support verification \u2705</li> <li>support verification over multiple proxies \u2705</li> <li>prototype assertion \u2705</li> </ul>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#supported-versions","title":"Supported Versions","text":"<p>Versions currently being supported with security updates:</p> Version Supported latest"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please use an Issue to report vulnerabilities.</p> <p>If security bug is discovered, following actions will be taken:</p> <ul> <li>Confirm the problem and determine the affected versions.</li> <li>Audit code to find any potential similar problems.</li> <li>Prepare fixes for all releases still under maintenance.</li> </ul>"},{"location":"development/badges/","title":"Create a badge","text":"<p>The badges are generate with Shields.io to generate our Badges. Use the following links in order to document or update any used badge and place the resulting SVG files the projects <code>assets/images</code> folder.</p>"},{"location":"development/badges/#badges","title":"Badges","text":"<ul> <li>Latest release</li> </ul> <pre><code>curl \"https://img.shields.io/badge/Release-0.3.0--rc08-blueviolet.svg?style=flat\"  -s -o badge-release-latest.svg\n</code></pre> <ul> <li>Platforms</li> </ul> <pre><code>curl \"https://img.shields.io/badge/Platform-Android%20|%20JVM%20|%20Js%20|%20iOS%20|%20macOS%20|%20watchOS%20|%20tvOS%20|%20LinuxX64%20|%20MingwX64%20-blue.svg\"  -s -o badge-platform-support.svg\n</code></pre> <ul> <li>License</li> </ul> <pre><code>curl \"https://img.shields.io/badge/license-Apache_2.0-blue.svg\" -s -o badge-license.svg\n</code></pre>"},{"location":"development/badges/#license","title":"License","text":"<p>Shields is licensed under Creative Commons Zero v1.0 Universal (as of 2022-02-23)</p>"},{"location":"development/code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"development/code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body, size, disability, ethnicity, class, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"development/code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"development/code-of-conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"development/code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"development/code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior should be reported. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"development/code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available here.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>When contributing to this project, this document should help you get started.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code Of Conduct","text":"<p>This project adheres to the Contributor Covenant Code Of Conduct. By participating, you are expected to uphold this code.</p>"},{"location":"development/contributing/#issues","title":"Issues","text":"<p>GitHub issues are the way to track bugs and enhancements.</p> <p>Issues are hold in high regards in this project, so please feel free to open issue for:</p> <ul> <li>Questions to help to improve the user experience</li> <li>Ideas which are a great source for contributions</li> <li>Problems show where this project is lacking or not working as expected.</li> </ul> <p>If you are reporting a problem, please provide as much information as possible, since this will help us to fix it. This includes, if possible, a description or small sample project how to reproduce the problem.</p> <p>Also please check out first if an issue had been already opened with your request.</p>"},{"location":"development/contributing/#contribute-code","title":"Contribute Code","text":""},{"location":"development/contributing/#development-process","title":"Development Process","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Android Studio 2022.1.1 or later</li> <li>Java 11</li> <li>Kotlin 1.7.20</li> <li>Gradle 7.5.1</li> </ul>"},{"location":"development/contributing/#features","title":"Features","text":"<p>Every change has to branch of from <code>main</code> and use this branch naming convention:</p> <ul> <li><code>feature/{type_of_change}-{short_description}</code></li> </ul> <p><code>main</code> must be always in releasable state.</p>"},{"location":"development/contributing/#type-of-change","title":"Type Of Change","text":"<ul> <li>add for new features or functionality</li> <li>change for changes in existing features or functionality</li> <li>deprecated for features which are at their end of life and will be removed in the future</li> <li>remove for removed features or functionality</li> <li>fix for any bug fixes</li> <li>bump for dependency updates</li> <li>security in case of vulnerabilities</li> </ul> <p>Examples:</p> <ul> <li><code>feature/add-awesome-hashing-algorithm</code></li> <li><code>feature/remove-not-so-awesome-algorithm</code></li> <li><code>feature/fix-algorithm-corner-case</code></li> <li><code>feature/bump-lib-to-1.3.0</code></li> </ul>"},{"location":"development/contributing/#pull-request","title":"Pull Request","text":"<p>Pull requests are always welcome!</p> <p>If you (going to) contribute, please make sure you made clear which problem you are attempt solve or what is nature of your improvement.</p>"},{"location":"development/contributing/#create-pull-request","title":"Create Pull Request","text":"<p>Please use our title pattern: <code>{type of change} {short description}</code>:</p> <p><code>type of change</code> can be:</p> <ul> <li>Add for new features or functionality,</li> <li>Change for changes in existing features or functionality,</li> <li>Deprecated for features which are at their end of life and will be removed in the future,</li> <li>Remove for removed features or functionality,</li> <li>Fix for any bug fixes,</li> <li>Security in case of vulnerabilities,</li> <li>Bump for dependency updates,</li> </ul> <p>followed by a <code>short description</code> of your change.</p> <p>Example:</p> <ul> <li>Add awesome hashing algorithm</li> <li>Changed thumbnail generation</li> </ul> <p>Pull requests must fill the provided template. Put N/A when a paragraph cannot be filled.</p> <p>Labels should be used (enhancement,bugfix, help wanted etc...) to categorise your contribution.</p> <p>Important: Work in progress pull-requests should be created as a draft.</p>"},{"location":"development/contributing/#code-review","title":"Code Review","text":"<p>Your contribution has to meet these criteria:</p> <ul> <li> Functional and fitting in the project</li> <li> Code style and naming conventions followed</li> <li> Test written and passing</li> <li> Existing Tests still passing</li> <li> Continuous Integration build passing</li> <li> Cross platform testing done for all supported platforms</li> <li> Documentation updated (if necessary)</li> <li> Changelog updated (if necessary)</li> </ul>"},{"location":"development/contributing/#dependencies-using-other-licenses","title":"Dependencies using other licenses","text":"<p>Contributing code and introducing dependencies into the repository from other projects that use one of the following licenses is allowed.</p> <ul> <li>MIT</li> <li>ISC</li> <li>Apache 2.0</li> </ul> <p>Any other contribution needs to be signed off by the project owners.</p>"},{"location":"development/releasing/","title":"Releasing","text":"<p>Releases are automatically created from added tags using GitHub Actions.</p> <p>A tag needs to be in the form of <code>v{major}.{minor}.{patch}</code>.</p>"},{"location":"development/releasing/#release-preparation","title":"Release preparation","text":"<ol> <li> <p>Create a release branch of from <code>main</code> branch with this pattern:</p> </li> <li> <p><code>release/{major}.{minor}/prepare-{major}.{minor}.{patch}</code></p> </li> <li> <p>Update changelog.md by creating a new Unreleased section and change current unreleased to release version</p> </li> <li>Update the latest release badge</li> </ol>"},{"location":"development/releasing/#release","title":"Release","text":"<p>For a release, this project uses GitHub releases:</p> <ol> <li>Create a new release</li> <li>Set the tag</li> <li>Set the title</li> <li>Add a description in form of a changelog</li> <li>Publish when ready</li> </ol>"},{"location":"howto/advanced/","title":"Advanced Concepts","text":""},{"location":"howto/advanced/#spying","title":"Spying","text":"<p>KMock supports Spying to a certain degree. While you still need to instantiate the subject to spy on (SO) by hand, you can delegate the SO to <code>kspy</code> and voila habemus spy!</p> <p>However Spying is disabled by default and is selective. To enable it please take a look at the Configuration of the Gradle Plugin.</p> <p>Once it is enabled KMock will generate an additional factory <code>kspy</code>. <code>kspy</code> works similar to <code>kmock</code> and takes 3 arguments <code>spyOn</code>, <code>collect</code> and <code>freeze</code>. <code>spyOn</code> expects the SO and you need to reference the Mock Class.</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val subjectToSpyOn = AnyImplementation()\n    val someInstance: SomeInterfaceMock = kspy(spyOn = subjectToSpyOn)\n\n   ...\n}\n</code></pre> <p>Also as with <code>kmock</code>, if the Template is generic you have to delegate an additional argument <code>templateType</code> which must be the KClass of the Template the Spy is referring to. Spies for MultiMocks will always treated like they are generic. This means you have to delegate all template types the  multi mock is referring to:</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val subjectToSpyOn = AnyMultiImplementation()\n    val someInstance: SomeInterfaceMock = kspy(\n        spyOn = subjectToSpyOn,\n        templateType0 = CharSequence::class,\n        templateType1 = Comparable::class,\n    )\n   ...\n}\n</code></pre> <p>You still can override specific methods or properties by using the corresponding Proxy Property. In other words methods or properties of an SO are used instead of throwing an error, if no behaviour or stub was assigned to a Proxy, so it acts completely non intrusive.</p> <p>Note</p> <p>Setters are always invoked.</p>"},{"location":"howto/advanced/#special-behaviour-of-spies","title":"Special behaviour of Spies","text":"<p>In terms of Spies there is one big difference you need to be aware of. Since Build-In methods like <code>equals</code> are delegated to the SO as well it might result in a behaviour which is not obvious right away:</p> <pre><code>@Test\nfun sampleTest() {\n   val subjectToSpyOn = AnyImplementation()\n   val someInstance: SomeInterfaceMock = kspy(subjectToSpyOn)\n\n   assertTrue((someInstance as Any) == someInstance) // will pass\n   assertTrue((someInstance as Any) == subjectToSpyOn) // will pass\n   assertTrue((subjectToSpyOn as Any) == someInstance) // will fail\n}\n</code></pre> <p>While the first and second Assertion passes the last won't. Why is it that? KMock uses inheritance not reflection as you remember. The last assertion fails since <code>AnyImplementation</code> has no custom implementation of <code>equals</code> and uses the default one. If <code>AnyImplementation</code> makes a custom comparison while taking only properties into account, the Assertion may pass.</p>"},{"location":"howto/advanced/#relaxing","title":"Relaxing","text":"<p>KMock also facilitates Relaxation to a certain degree and will hopefully get better in it over time. However it requires boilerplate code done by you. The Relaxation of methods which return <code>Unit</code> is Build-In feature, so do not worry about it. You only need to switch <code>relaxUnitFun</code> to <code>true</code> and be done with it.</p> <p>Similar things apply for Build-In methods, if they are enabled. They will fallback to their parents Build-In methods if no return value is set for them.</p> <p>To get full Relaxation support you need to implement a Relaxer function and annotate it properly: <pre><code>@Relaxer\ninternal inline fun &lt;reified T&gt; relax(id: String): T {\n   ...\n}\n</code></pre> The Annotation <code>@Relaxer</code> tells KMock that a Relaxer is present and is up for usage. The Relaxer can be an arbitrary function but has to follow a specific signature, similar as shown above. The function can be either inline or not. The type parameter can be either <code>reified</code> or not, but must be present and used as the return value. There can be only one type parameter. The function can be marked as internal or not, but must be visible by the Mocks. Also the function must take exactly one argument, which is a String. This argument will be provided when invoked by a Proxy and is its id. You may use it to differentiate between Proxies. At last you need to switch relaxing on by adding <code>relaxed = true</code> to <code>kmock</code>.</p> <p>However since this sounds cumbersome you may want to use it together with KFixture.</p> <p>Well, in certain cases the type parameter will not work as return value - Generics. If KMock encounters Generics as return values of a method/property it adds additional arguments (<code>type$Idx</code>) to invocation of the Relaxer Function For example: <pre><code>relax(\n    proxyId,\n    type0 = Any::class,\n    type1 = Comparable::class,\n)\n</code></pre> This means KMock expects you to provide a proper definition of <code>fun relax(proxyId: String, type0: KClass&lt;Any&gt;, type1: KClass&lt;Comparable&lt;Any&gt;&gt;): Any</code>. The amount of type arguments depends on the boundaries of the generic return type. For example <code>&lt;T&gt; fun method(): T where T: Any, T: Comparable&lt;Any&gt;</code> will resolved to the invocation above.</p>"},{"location":"howto/advanced/#memory-model","title":"Memory Model","text":"<p>KMock still uses Kotlin's \u2018old\u2019 Memory Model. Therefore you might run into some trouble in certain cases.</p> <p>Both factory functions - <code>kmock</code> and <code>kspy</code> - take an argument <code>freeze</code> which is true by default. This means everything which is delegated to an Proxy (including Relaxation) or Verifier must conform with the freezing Memory Model of Kotlin. By switching <code>freeze</code> to <code>false</code> it changes the flavour to non-freezing.</p> <p>If you use non freezing Mocks, make sure you use the corresponding Asserter/Verifier (<code>NonFreezingVerifier</code>/<code>NonFreezingAsserter</code>) and all interacting Mocks are non-freezing as well. This is inconvenient for now but will go away once the new Memory Model is more stable.</p>"},{"location":"howto/advanced/#customization","title":"Customization","text":""},{"location":"howto/advanced/#argumentconstraints","title":"ArgumentConstraints","text":"<p>KMock is capable of using your custom defined ArgumentConstraints. You can simply extend <code>ArgumentConstraint</code> of the <code>KMockContract</code> and implement the functionality you require and use it. Done!</p>"},{"location":"howto/advanced/#verification","title":"Verification","text":"<p>While nearly all Assertion/Verification methods are not able to extended, you are still able to customize <code>verify</code> due to the power of extension function for either the <code>Proxy</code>, <code>FunProxy</code>, <code>PropertyProxy</code>, <code>SyncFunProxy</code> or <code>AsyncFunProxy</code> Interface of the <code>KMockContract</code>. KMock exposes 4 functions which are intended for this purpose. <code>getArgumentsByType</code>, <code>getAllArgumentsByType</code> and <code>getAllArgumentsBoxedByType</code> working only for FunProxies, while <code>getArgumentsForCall</code> works for all Proxy types. <code>getArgumentsByType</code> can be used to retrieve Arguments for a specific call and type, <code>getAllArgumentsByType</code> and <code>getAllArgumentsBoxedByType</code> collecting over all invocations. The main difference between the latter methods is simply that <code>getAllArgumentsByType</code> will collect arguments in a linear order, while <code>getAllArgumentsBoxedByType</code> will box them in a List per call.</p> <p>Use those methods with caution, since they are likely subject to changes, once the concept of assertions gets a second look. KMock itself uses <code>getArgumentsForCall</code> which you might wanna use as well while working with PropertyProxies or you need a type unaware method to extract arguments from Proxies.</p> <p>Happy coding!</p>"},{"location":"howto/annotations/","title":"Declaring a Mock","text":"<p>To declare Mocks you have to use KMock's annotations or those you have declared in the KMock's Gradle Extension. You can declare Mocks in a central place (per platform) or per test suite. However declaring them in a central place is discouraged since it violates the DAMP unit tests principle.</p>"},{"location":"howto/annotations/#build-in-annotations","title":"Build-In Annotations","text":"<p>KMock offers you 6 annotations which are considered as stable to declare a Mock:</p> <ul> <li>Mock/MultiMock for Platform specific Mocks,</li> <li>MockShared/MultiMockShared for Shared Sources (like native),</li> <li>MockCommon/MultiMockCommon for commonTest.</li> </ul>"},{"location":"howto/annotations/#single-interface-mocks","title":"Single Interface Mocks","text":"<p>Declaring a Mock for common or platforms works alike. Mock/MockCommon takes an arbitrary amount of interfaces which will used as Templates to generate Mocks of: <pre><code>import tech.antibytes.kmock.MockCommon\n\n@MockCommon(\n   SampleInterface::class,\n   OtherSampleInterface::class,\n   ...\n)\nclass SampleTestSet {\n   ...\n}\n</code></pre></p> <p>MockShared takes an additional argument <code>sourceSetName</code> in order to associate the Templates with the Shared Source Set like <code>iosTest</code>. You can also use only a short reference instead of the full name (e.g. long: <code>iosTest</code>, short: <code>ios</code>): <pre><code>import tech.antibytes.kmock.MockShared\n\n@MockShared(\n   \"native\",\n   SampleInterface::class,\n   OtherSampleInterface::class,\n   ...\n)\nclass SampleTestSet {\n   ...\n}\n</code></pre></p> <p>Tip</p> <p>You do not have to mix those Annotations per test set. KMock is totally fine if you declare a Template in one source as common and in another source as platform source. It will resolve any conflicts according to their precedence in Kotlin's hierarchical source sets. As a rule of thumb - you need for Single Interface Mocks one Annotation per test set.</p>"},{"location":"howto/annotations/#multi-interface-mocks","title":"Multi Interface Mocks","text":"<p>KMock is also capable of generate Mocks based on multiple interfaces. Similar to Single Interface Mocks, MultiMock and MultiMockCommon can declare Mocks in the very similar way: <pre><code>import tech.antibytes.kmock.MultiMockCommon\n\n@MultiMockCommon(\n    \"MergedCommon\",\n    SampleDomainObject::class,\n    ExampleContract.DecoderFactory::class\n)\nclass SampleTestSet {\n    ...\n}\n</code></pre> In difference to Single Interface Mocks, Multi Interface Mocks Annotations can be applied multiple times per test set. Also all Multi Interface Mocks Annotations need an additional argument <code>name</code> which will be used as name for the generated Mock. All referenced Interfaces will then be merged into one Mock. As with Single Interface Mocks, the Annotation for Shared Sources needs an additional argument <code>sourceSetName</code> to bind the generated Mock to a source set: <pre><code>import tech.antibytes.kmock.MultiMockShared\n\n@MultiMockShared(\n    sourceSetName = \"nativeTest\",\n    name = \"MergedShared\",\n    SampleDomainObject::class,\n    ExampleContract.DecoderFactory::class\n)\nclass SampleTestSet {\n    ...\n}\n</code></pre></p> <p>Warning</p> <p>Do not use this feature to create one Mock for all tests. It was never intended for that.</p> <p>Note</p> <p>Even if it is not directly intended you can use Multi-Interface Annotations to produce Aliases for Single-Interface Mocks.</p>"},{"location":"howto/annotations/#custom-annotations","title":"Custom Annotations","text":"<p>You can also use your custom Annotations in order to ease the handling with Shared Sources. Your Annotations are not allowed to reference common and have to take a arbitrary amount of KClass (aka vararg) for Single Interface Mocks. For Multi Interface Mocks your Annotations have to take as the very first argument a String additionally to the KClasses: <pre><code>package my.package\n\n@Retention(AnnotationRetention.SOURCE)\n@Target(AnnotationTarget.CLASS)\n@MustBeDocumented\nannotation class Custom(vararg val interfaces: KClass&lt;*&gt;)\n\n@Repeatable\n@Retention(AnnotationRetention.SOURCE)\n@Target(AnnotationTarget.CLASS)\n@MustBeDocumented\nannotation class MultiCustom(val name: String, vararg val interfaces: KClass&lt;*&gt;)\n</code></pre></p>"},{"location":"howto/annotations/#experimental-annotations","title":"Experimental Annotations","text":"<p>With 0.2.0 KMock offers 2 new experimental Annotations - <code>KMock</code> and <code>KMockMulti</code> which lift the need of telling KMock to which Source Set a Mock binds. Those Annotations will determine the Source Set of a Mock based on the contexts they are declared. However those Annotations are considers as experimental since there might be edge cases which are not covered by them. They can be used in the exact same way as <code>Mock</code> or <code>MockMulti</code>: <pre><code>import tech.antibytes.kmock.MultiMockShared\n\n@KMock(\n    SampleInterface::class,\n    OtherSampleInterface::class,\n    ...\n)\n@KMockMulti(\n    name = \"MergedShared\",\n    SampleDomainObject::class,\n    ExampleContract.DecoderFactory::class\n)\nclass SampleTestSet {\n    ...\n}\n</code></pre></p>"},{"location":"howto/assertion/","title":"Assertion and Verification","text":"<p>As other libraries KMock offers a way to assert or verify invocations of Proxies (not Mocks!).</p>"},{"location":"howto/assertion/#expectations-method","title":"Expectations Method","text":"<p>Assertion and Verification share the same API - Expectation Methods. While those methods will behave similarly in both contexts, they have different nuances.</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SampleRemoteRepositoryMock = kmock()\n\n    ...\n\n    // assert\n    verify(exactly = 1) { someInstance._fetch.hasBeenCalledWith(\"someUrl\") }\n    assertProxy { someInstance._find.hasBeenCalledWith(\"something\") }\n}\n</code></pre> <p><code>hasBeenCalledWith</code> for example is such a Expectation Method. Other Expectation Method for FunProxies are:</p> Method What it does <code>hasBeenCalled</code> determines if the Proxy was invoked. <code>hasBeenCalledWithVoid</code> determines if the Proxy was invoked without any arguments. <code>hasBeenCalledWith</code> determines if the Proxy was invoked with the given arguments.The arguments must follow the order of the Templates arguments but can contain gaps and do not need exhaustive. <code>hasBeenStrictlyCalledWith</code> determines if the Proxy was invoked with the given arguments.The arguments must follow the order of the Template arguments strictly and must provide all arguments in their order. <code>hasBeenCalledWithout</code> determines if the Proxy was invoked without the given arguments. <p>PropertyProxies have their own specialized set of Expectation Methods:</p> Method What it does <code>wasGotten</code> determines if the Proxy was invoked as a getter. <code>wasSet</code> determines if the Proxy was invoked as a setter. <code>wasSetTo</code> determines if the Proxy was invoked as a setter with the given argument."},{"location":"howto/assertion/#argument-constraints","title":"Argument Constraints","text":"<p>While it might not always be desirable to assert/verify against an concrete value, KMock also offers ArgumentConstraints. For example if you simply want to confirm that a Proxy was called with a certain type you may do the following:</p> <pre><code>@Test\nfun sampleTest() {\n   val someInstance: SampleRemoteRepositoryMock = kmock()\n   ...\n\n   verify(exactly = 1) {\n       someInstance._fetch.hasBeenCalledWith(any(String::class))\n   }\n}\n</code></pre> <p>Internally all concrete types will be converted into an <code>eq</code> constraint. For example an Expectation Method is called with <code>42</code>. <code>42</code> will be converted into <code>eq(42)</code>. Currently the following constraints are implemented:</p> ArgumentConstraint What it does <code>and</code> which allows to chain multiple values or constraints together with an logical and. <code>any</code> matches always (including null).If a concrete type was given it matches only if a recorded argument fulfils the expected type (exclusive null). <code>eq</code> matches if the recorded argument is equal to the expected argument. <code>isNot</code> matches if the recorded argument is not equal to the expected argument. <code>isSame</code> matches if the recorded argument is identical as the expected argument. <code>isNotSame</code> matches if the recorded argument is not identical as the expected argument. <code>not</code> matches if the negated outcome of a given ArgumentConstraint matches. <code>or</code> which allows to chain multiple values or constraints together with a logical or."},{"location":"howto/assertion/#single-proxy-assertionverification","title":"Single Proxy Assertion/Verification","text":"<p>As you might now already seen KMock offers for Single Proxy Assertion/Verification <code>verify</code> and <code>assertProxy</code>. So what is now exactly the difference and what has that to do with the Expectation Methods? Well, <code>verify</code> will look if any invocation of the Proxy will match the given Expectation. <code>assertProxy</code> will go through the invocation from the first to latest. In short <code>verify</code> can skip invocations while <code>assertProxy</code> cannot.</p> <p>Also both functions are not capable to be used in order to make statements about the interactions between Proxies. However you can use <code>assertProxy</code> with multiple Proxies: <pre><code>@Test\nfun sampleTest() {\n    val someInstance: SampleRemoteRepositoryMock = kmock()\n    ...\n\n    verify(atLeast = 1) {\n        someInstance._fetch.hasBeenCalledWith(any(String::class))\n    }\n\n    verify(atLeast = 1) {\n        someInstance._find.hasBeenCalledWith(any(String::class))\n    }\n\n    assertProxy {\n        someInstance._fetch.hasBeenCalledWith(any(String::class))\n        someInstance._fetch.hasBeenCalledWith(any(String::class))\n\n        someInstance._find.hasBeenCalledWith(any(String::class))\n    }\n}\n</code></pre> As shown above you can and assuming <code>fetch</code> has been called 2x and with that <code>_fetch</code> was invoked 2x. Also assuming <code>find</code> was invoked, <code>verify</code> and <code>assertProxy</code> will pass. However you cannot say if <code>fetch</code> was called before or after <code>find</code>. Assuming now <code>fetch</code> has been called only once, <code>verify</code> will still pass, while <code>assertProxy</code> will fail. Since <code>verify</code> is less strict about the order it checks if a Proxy was invoked <code>exactly</code>, <code>atLeast</code> or <code>atMost</code> certain times. <code>assertProxy</code> on the other hand will always tell what is wrong with current and where but will only cover those invocation you told it cover. In order to ensure you covered all invocations via <code>assertProxy</code> you can use <code>hasNoFurtherInvocations</code>.</p> <p>Tip</p> <p>As a rule of thumb - if you want to cover a Proxy which is invoked multiple times you should consider using verify. If you cover a proxy which is invoked only once you should consider <code>assertProxy</code>.</p> <p>Note</p> <p>You need only one <code>assertProxy</code> per test case, strictly speaking. In terms of <code>verify</code> you need one per Verification.</p>"},{"location":"howto/assertion/#experimental-operators","title":"Experimental Operators","text":"<p>Due to the special nature of <code>verify</code> KMock offers a additional way to make <code>verify</code> more versatile and expressive - Operators: Consider following source: <pre><code>interface SampleThing {\n    fun method(arg0: String, arg1: Int, arg2: Any)\n}\n</code></pre> Now you can use Operators with <code>verify</code> like : <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SampleThingMock = kmock()\n\n    ...\n    verify(atLeast = 1) {\n        someInstance._find.method(\"payload\", 23, \"any\") or\n            someInstance._find.method(\"payload\", 42, \"notAny\")\n    }\n\n}\n</code></pre> Instead of: <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SampleThingMock = kmock()\n\n    ...\n    verify(atLeast = 1) {\n        someInstance._find.method(\"payload\", or(eq(23), eq(42)), or(eq(\"any\"), eq(\"notAny\")))\n    }\n\n}\n</code></pre></p> <p>These Operators are still experimental but will become stable soon. Other Operators are:</p> Operator What it does <code>union</code> resolves the union of 2 Expectations. <code>or</code> is an alias of <code>union</code>. <code>intersection</code> resolves the intersection of 2 Expectations. <code>and</code> is an alias of <code>intersection</code>. <code>diff</code> resolves the symmetrical difference of 2 Expectations. <code>xor</code> is an alias of <code>diff</code>"},{"location":"howto/assertion/#multi-proxy-assertionverification","title":"Multi Proxy Assertion/Verification","text":"<p>To keep track of interaction between Proxies KMock offers also a way. You'll need to inject a Asserter/Verifier into the Mocks when they are initialized via the <code>collector</code> argument of <code>kmock</code> or <code>kspy</code>.</p> <p>Note</p> <p>Asserter and Verifier are the same. In fact Verifier is a type alias of Asserter.</p> <p>Import</p> <p>Make sure you use the fitting type of Asserter/Verifier according to the Memory Model.</p> <pre><code>fun sampleTest() {\n    // arrange\n    val asserter = Asserter()\n    val someInstance: SomeInterfaceMock = kmock(collector = asserter)\n    val someInstanceOther: SomeInterfaceMock = kmock(collector = asserter)\n\n   ...\n    // assert\n    asserter.assertOrder {\n       someInstance._someProperty.wasGotten()\n       someInstanceOther._someMethod.hasBeenCalled()\n       someInstance._someMethod.hasBeenCalled()\n   }\n}\n</code></pre> <p>KMock offers 3 flavours to deal with interaction of multiple Proxies - <code>assertOrder</code>, <code>verifyStrictOrder</code> and <code>verifyOrder</code>.</p> <ul> <li><code>assertOrder</code> is super strict - you must cover all invocations of all collected Proxies in order and exhaustively.</li> <li><code>verifyStrictOrder</code> is less strict - it allows you to skip an arbitrary number of invocations of Proxies, but once you started to verify them it acts like <code>assertOrder</code>.</li> <li><code>verifyOrder</code> is even less strict but also less descriptive in terms of errors - it allows you to skip an arbitrary invocations of Proxies and will only care about the relative order of Proxies.</li> </ul> <p>All 3 flavours use the same API as verify/assertProxy to determine if a invocation is valid or not. For example:</p> <p><pre><code>fun sampleTest() {\n    // arrange\n    val asserter = Asserter()\n    val someInstance: SomeInterfaceMock = kmock(collector = asserter)\n    val someInstanceOther: SomeInterfaceMock = kmock(collector = asserter)\n\n   ...\n    // assert\n    asserter.verifOrder {\n       someInstance._someProperty.wasGotten()\n       someInstanceOther._someMethod.hasBeenCalled()\n       someInstance._someMethod.hasBeenCalled()\n   }\n}\n</code></pre> To make the difference more clear: * <code>assertOrder</code> will fail if the invocation will not exactly in the order <code>someProperty</code> - <code>someMethod</code> - <code>someMethod</code> and there are more than these invocations. * <code>verifyStrictOrder</code> will fail if the invocation will not exactly in the order <code>someProperty</code> - <code>someMethod</code> - <code>someMethod</code> but it will not care if any invocation happens before that chain. * <code>verifyOrder</code> will fail if the invocation is not in the relative order <code>someProperty</code> - <code>someMethod</code> - <code>someMethod</code> but it will not care if any invocation happens before, after or in between them.</p> <p>Optionally you can use <code>ensureVerificationOf</code> if you need any insurance that all Proxies have been covered during a run by a Verifier/Asserter.</p> <p>Verifier/Asserter can additionally be initialised with the <code>coverAllInvocations</code> flag, which is false by default. This flag forces Proxies, which are excluded from Verification/Assertion by default to be covered during a test run. This is only important if you have to cover build-in methods like <code>equals</code>, since they are excluded from Verification via Verifier/Asserter by default due to their special nature.</p>"},{"location":"howto/assertion/#teardown","title":"Teardown","text":"<p>As with Mocks Verifier/Asserter have a <code>clear</code> method, which opens them up for reuse. So do not forget to call it.</p>"},{"location":"howto/assertion/#compatibility-with-proxy-access-methods","title":"Compatibility with Proxy Access Methods","text":"<p>In case you use Proxy Access Methods with Coroutines (aka <code>asyncProxyOf</code>) you may have to use the corresponding Verification/Assertion methods. They act the very same way as they synchronous counter parts. The only difference is that they start with the prefix <code>async</code> like <code>asyncVerify</code>.</p> <p>Important</p> <p>Do not use them with direct Proxy Access together - their soul purpose is bound to <code>asyncProxyOf</code> and <code>asyncProxyOf</code> only.</p>"},{"location":"howto/install/","title":"Installation","text":"<p>KMock is capable to work with a variety of projects.</p>"},{"location":"howto/install/#preparation","title":"Preparation","text":"BuildScriptBuildSrc <p>In your build.gradle.kts: <pre><code>buildScript {\n    repositories {\n        ...\n        mavenCentral()\n    }\n    dependencies {\n        ...\n        classpath(\"tech.antibytes.kmock:kmock-gradle:$KMockVersion\")\n    }\n}\n\nallprojects {\n        ...\n    repositories {\n        ...\n        mavenCentral()\n    }\n}\n</code></pre></p> <p>In your buildSrc/build.gradle.kts: <pre><code>repositories {\n    ...\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"tech.antibytes.kmock:kmock-gradle:$KMockVersion\")\n}\n</code></pre></p> <p>In your root project build.gradle.kts: <pre><code>allprojects {\n        ...\n    repositories {\n        ...\n        mavenCentral()\n    }\n}\n</code></pre></p> <p>In case you need to consume snapshots:</p> BuildScriptBuildSrc <p>In your build.gradle.kts: <pre><code>buildScript {\n    repositories {\n        ...\n        maven {\n            url = java.net.URI(\"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\")\n\n            content {\n                includeGroup(\"tech.antibytes.kmock\")\n            }\n        }\n    }\n}\n...\n\nallprojects {\n        ...\n    repositories {\n        ...\n        maven {\n            url = java.net.URI(\"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\")\n            content {\n                includeGroup(\"tech.antibytes.kmock\")\n            }\n        }\n    }\n}\n</code></pre></p> <p>In your buildSrc/build.gradle.kts: <pre><code>repositories {\n    ...\n    maven {\n        url = java.net.URI(\"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\")\n\n        content {\n            includeGroup(\"tech.antibytes.kmock\")\n        }\n    }\n}\n...\n</code></pre> In your root project build.grade.kts: <pre><code>allprojects {\n        ...\n    repositories {\n        ...\n        maven {\n            url = java.net.URI(\"https://raw.github.com/bitPogo/maven-snapshots/main/snapshots\")\n            content {\n                includeGroup(\"tech.antibytes.kmock\")\n            }\n        }\n    }\n}\n</code></pre></p> <p>Warning</p> <p>Snapshots are not meant to be stable and will be removed after a release. Also if you need a stable snapshot due to a specific issue please ask for a pined snapshot.</p>"},{"location":"howto/install/#add-it-to-your-project","title":"Add it to your project","text":"AndroidJVMJS <pre><code>plugins {\n    ...\n    id(\"tech.antibytes.kmock.kmock-gradle\")\n}\n\nkmock {\n    rootPackage = \"my.root.package\"\n}\n\ndependencies {\n    ...\n    testImplementation(\"tech.antibytes.kmock:kmock:$KMockVersion\")\n    ...\n}\n</code></pre> <pre><code>plugins {\n    ...\n    id(\"tech.antibytes.kmock.kmock-gradle\")\n}\n\nkmock {\n    rootPackage = \"my.root.package\"\n}\n\ndependencies {\n    ...\n    testImplementation(\"tech.antibytes.kmock:kmock:$KMockVersion\")\n    ...\n}\n</code></pre> <pre><code>import tech.antibytes.gradle.kmock.KMockExtension\n...\n\nplugins {\n    id(\"org.jetbrains.kotlin.js\")\n    ...\n\n    id(\"tech.antibytes.kmock.kmock-gradle\")\n}\n\nkotlin {\n    ...\n}\n\nkmock {\n    rootPackage = \"my.root.package\"\n}\n\ndependencies {\n    ...\n    testImplementation(\"tech.antibytes.kmock:kmock:$KMockVersion\")\n    ...\n}\n</code></pre> <p>Note</p> <p>While the Gradle Plugin will add for <code>release</code> and <code>debug</code> the source folders, it will not configure additional build types or flavours. If make use of that feature you need to add the generated files yourself. You may find all generated sources in the project's build folder under <code>generated/ksp</code> and the documentation on build-variants can be found here.</p> Kotlin Multiplatform <pre><code>import tech.antibytes.gradle.kmock.KMockExtension\n...\n\nplugins {\n    ...\n\n    id(\"tech.antibytes.kmock.kmock-gradle\")\n}\n\nkotlin {\n    ...\n\n    sourceSets {\n        ...\n        val commonTest by getting {\n            dependencies {\n                ...\n                implementation(\"tech.antibytes.kmock:kmock:$KMockVersion\")\n                ...\n            }\n        }\n        ...\n    }\n    ...\n}\n\nkmock {\n    rootPackage = \"my.root.package\"\n}\n</code></pre> <p>Warning</p> <p>For KMP or KJs it is mandatory to configure KMock after your projects <code>kotlin</code> block has been set up as shown above. This is due to the fact that Kotlin brings its own system of source sets and Kotlin Symbol Processing (KSP) must be configured during the evaluation of your project.</p> <p>Tip</p> <p>You may find a full examples, how to set up KMock properly, in the Playground.</p> <p>Important</p> <p>Since KmpTest are running always in parallel, it can cause Mocks not to be generated properly. To counter this, KMock will chain the test together with their KspTasks in a arbitrary order. This effectively disables the parallel execution for now. If you want to deactivate this behaviour you may add <code>kmock.noParallelTests</code> in your gradle.properties to false.</p>"},{"location":"howto/install/#newer-ksp-or-kotlin-versions","title":"Newer KSP or Kotlin Versions","text":"<p>KMock eventually not use the latest version of Kotlin or KSP. This is mainly done to enable keep it open to projects which cannot update immediately. However since this might cause problems or noise you can force a new version of KSP:</p> BuildScriptBuildSrc <p>In your build.gradle.kts: <pre><code>buildscript {\n    ...\n    dependencies {\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\")\n        classpath(\"tech.antibytes.kmock:kmock-gradle:$KMockVersion\") {\n            exclude(\n                group = \"com.google.devtools.ksp\",\n                module = \"symbol-processing-api\"\n            )\n            exclude(\n                group = \"com.google.devtools.ksp\",\n                module = \"com.google.devtools.ksp.gradle.plugin\"\n            )\n        }\n        classpath(\"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\")\n        classpath(\"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\")\n    }\n}\n</code></pre></p> <p>In your buildSrc/build.gradle.kts: <pre><code>dependencies {\n    ...\n    implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.21\")\n    implementation(\"tech.antibytes.kmock:kmock-gradle:$KMockVersion\") {\n        exclude(\n            group = \"com.google.devtools.ksp\",\n            module = \"symbol-processing-api\"\n        )\n        exclude(\n            group = \"com.google.devtools.ksp\",\n            module = \"com.google.devtools.ksp.gradle.plugin\"\n        )\n    }\n    implementation(\"com.google.devtools.ksp:symbol-processing-api:1.6.21-1.0.5\")\n    implementation(\"com.google.devtools.ksp:com.google.devtools.ksp.gradle.plugin:1.6.21-1.0.5\")\n}\n</code></pre></p> <p>Warning</p> <p>Do not replace the Kotlin Version in the Runtime part of KMock!</p>"},{"location":"howto/proxy/","title":"Using Mocks","text":""},{"location":"howto/proxy/#before-you-start","title":"Before you start","text":"<p>Once you have declared the Mocks you are going to use, please run your test suite once. (Even if you have no meaningful tests defined yet.) This triggers the  Code Generation of Mocks and you may benefit from autocompletion in your Editor or IDE right away. All Mocks (including Multi Interface Mocks) end on<code>Mock</code> to ensure a unified way to reference them.</p>"},{"location":"howto/proxy/#proxies","title":"Proxies","text":"<p>KMock will add double members - Proxy Properties - (do not confuse them with PropertyProxies) to the generated Mock. All Proxy Properties are named with leading <code>_</code> followed by the Templates original name. In case Templates are overloaded the proxy names will get additional suffix lead by <code>With</code> and derived from the Templates arguments types to ensure its uniqueness as much as possible. In case there is are still collisions you have additional options via KMocks Gradle Plugin Extension</p> <p>KMock in general distinguishes between PropertyProxies and FunProxies, which are referring to either to properties or methods of a Template.</p>"},{"location":"howto/proxy/#funproxies","title":"FunProxies","text":"<p>FunProxies don't differentiate between asynchronous and synchronous in their API. Therefore anything works for both modi alike. KMock offers a simple way to facilitate stubbing. Consider following source: <pre><code>interface SampleRemoteRepository {\n    suspend fun fetch(url: String): Any\n    fun find(id: String): Any\n}\n</code></pre> You can deal with the resulting Mock for example like this: <pre><code>@Test\nfun sampleTest() {\n   // arrange\n   val someInstance: SampleRemoteRepositoryMock = kmock()\n\n   someInstance._fetch.returnValue = Any()\n   someInstance._find returns \"any\"\n\n   // act\n   val someOtherInstance = SomeClass(someInstance)\n   someOtherInstance.execute()\n   ...\n}\n</code></pre></p> <p>In short KMock allows to assign canned values which are returned once the Template Method is invoked. In case you need a more elaborate behaviour you can use SideEffects: <pre><code>@Test\nfun sampleTest() {\n   // arrange\n   val someInstance: SampleRemoteRepositoryMock = kmock()\n\n   someInstance._fetch run {\n       delay(20)\n       return Any()\n   }\n\n   someInstance._find.sideEffect = { id -&gt;\n       return if (id.isEmpty()) {\n           throw RuntimeException()\n       } else {\n           Any()\n       }\n   }\n\n   // act\n   val someOtherInstance = SomeClass(someInstance)\n   someOtherInstance.run()\n   ...\n}\n</code></pre></p> <p>You can use the following properties of FunProxies:</p> Property What it does <code>returnValue</code> The Proxy will return the always the given value. <code>returnValues</code> The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. <code>error</code> The Proxy will throw the given error/exception. <code>errors</code> The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. <code>sideEffect</code> The Proxy will execute the given SideEffect and returns its result. <code>sideEffects</code> The Proxy will execute each SideEffect and returns its result.  If only one SideEffect is left it will execute it until the run is completed. <p>Note</p> <p>Please be aware there is a precedence of invocation. <code>errors</code> is used over  <code>error</code>, <code>returnValue</code> is used over <code>errors</code>, <code>returnValues</code> is used over <code>returnValues</code>, <code>sideEffect</code> is used over <code>returnValues</code> and <code>sideEffects</code> is used over <code>sideEffect</code>. If no behaviour is set the Proxy simply fails and acts therefore intrusively.</p> <p>Additionally you can use the following infix methods to mutate its values:</p> Method What it does <code>returns</code> Alias setter of <code>returnValue</code>.The Proxy will return the always the given value. <code>returnsMany</code> Alias setter of <code>returnValues</code>.The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. <code>throws</code> Alias setter of <code>error</code>.The Proxy will throw the given error/exception. <code>throwsMany</code> Alias setter of <code>errors</code>.The Proxy will throw each value of the given list. If only one error/exception is left it will throw it until the run is completed. <code>run</code> Alias setter of <code>sideEffect</code>.The Proxy will execute the given SideEffect and returns its result. <code>runs</code> Alias setter of <code>sideEffects</code>.The Proxy will execute each SideEffect and returns its result.  If only one SideEffect is left it will execute it until the run is completed. <p>A last word to SideEffects. While they in general using the signature of the Template and therefore you can utilize the full power of the Kotlin's type system, there is 2 exceptions to this. If you work with Multi-Boundary Generics and declare them on Method level KMock cannot derive a certain type, since Kotlin has no Union Types per se. The same goes for recursive types as well (e.g. <code>T : Comparable&lt;T&gt;</code>). Those types are derived as <code>Any</code> and you have to make sure to cast them correctly if you use them.</p>"},{"location":"howto/proxy/#propertyproxies","title":"PropertyProxies","text":"<p>PropertyProxies work in a very similar fashion as FunProxies. Consider following source: <pre><code>interface SampleDomainObject {\n    val id: String\n    var something: Int\n}\n</code></pre></p> <p>In short KMock allows to assign simple canned values which are returned once the Template Property is invoked: <pre><code>@Test\nfun sampleTest() {\n   // arrange\n   val someInstance: SampleDomainObjectMock = kmock()\n\n   someInstance._id.getValue = \"Any\"\n   someInstance._something.set = { value -&gt;\n       if (value == 0) {\n           throw RuntimeException()\n       }\n   }\n\n   // act\n   val someOtherInstance = SomeClass()\n   someOtherInstance.execute(someInstance)\n   ...\n}\n</code></pre></p> <p>Property Setters are always using SideEffects but work completely non intrusive and have no need for a explicit setup. Property Getters can be use either stub values or a SideEffect. Both - Setter and Getter - do not allow multiple SideEffects since this should be considered as a clear sign that the usage of method is more appropriate instead.</p> <p>PropertyProxies have the following properties:</p> Property What it does <code>getValue</code> The Proxy will return the always the given value. <code>getValues</code> The Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. <code>get</code> The Proxy will execute the given SideEffect and return its result. <code>set</code> The Proxy will execute the given SideEffect. <p>Note</p> <p>Please be aware there is a precedence of invocation. <code>getValues</code> is used over <code>getValue</code> and <code>get</code> is used over <code>getValues</code>. If no behaviour is set the Proxy simply fails and acts intrusively.</p> <p>Additionally you can use the following infix methods to set values:</p> Method What it does <code>returns</code> Alias setter of <code>getValue</code>. Proxy will return the always the given value. <code>returnsMany</code> Alias setter of <code>getValues</code>. Proxy will return each value of the given list. If only one value is left it will return it until the run is completed. <code>runOnGet</code> Alias setter of <code>get</code>. Proxy will execute the given SideEffect and return its result. <code>runOnSet</code> Alias setter of <code>set</code>. Proxy will execute the given SideEffect."},{"location":"howto/proxy/#receiverproxies","title":"ReceiverProxies","text":"<p>While receivers are technically not a special type of Proxy they are still special. KMock will do what the compiler does with them and sees them as methods regardless if they are a property or not. The first argument of those methods will be always the type of the Receiver. In case the Template is a Property Receiver, KMock generates one or two methods which depends on the mutability of the Template Receiver. Additionally the generated Proxy is suffixed with <code>Getter</code>/<code>Setter</code>. In case the Template is a Method Receiver, KMock will just suffix the name with an additional <code>Receiver</code>. Unlike other libraries this makes it possible to access Receivers directly without the need of any workaround to reference them.</p>"},{"location":"howto/proxy/#the-kmock-factory","title":"The KMock Factory","text":"<p>As you might already seen at this point KMock generates also Factories to ease the initialization of Mocks. <code>kmock</code> takes 4 arguments: <code>collector</code>, <code>relaxed</code>, <code>relaxUnitFun</code> and <code>freeze</code>. <code>relax</code> and <code>relaxUnitFun</code> determine if relaxing should be used and are false by default. <code>freeze</code> determines which flavour for the Memory Model is used and is true by default if no custom default value is set.</p> <p>In case of Single Interface Mocks and the Template uses Generics an additional argument is mandatory - <code>templateType</code>. This argument takes the KClass of the Template:</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val genericThing: SomethingGenericMock&lt;Int&gt; = kmock(\n        templateType = SomethingGeneric::class,\n    )\n\n    ...\n}\n</code></pre> <p>In case of Multi-Interface Mocks and a Template uses Generics a additional arguments are mandatory - <code>templateType$Idx</code>. Those type take the KClass of the Templates:</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val genericThing: GenericMultiMock&lt;Int, String, *&gt; = kmock(\n        templateType0 = SomethingGeneric::class,\n        templateType1 = AnythingGeneric::class,\n    )\n\n    ...\n}\n</code></pre> <p>Also KMock will not merge compatible Generic Types, since it cannot be sure if they are independent or not. This means if you reference the Mock you always have to explicitly declare all generics.</p>"},{"location":"howto/proxy/#teardown","title":"Teardown","text":"<p>All Mocks are generated with a <code>_clearMock</code> method which clears all Proxies owned by the Mock. This enables you to use Mocks per test suite and not only per test case:</p> <pre><code>@MockCommon(\n    SampleInterface::class,\n    ...\n)\nclass SampleTestSet {\n    private val someInstance: SomeInterfaceMock = kmock()\n\n    @AfterTest\n    fun tearDown() {\n        someInstance._clearMock()\n    }\n\n    @Test\n    fun sampleTest() {\n        ...\n    }\n\n}\n</code></pre>"},{"location":"howto/proxy/#experimental-proxy-access-methods","title":"Experimental Proxy Access Methods","text":"<p>0.2.0 KMock introduces a new way to work with Proxies. This is done to provide a more robust way in terms of refactoring. However since those methods need a lot more thought and optimization they are considered as experimental but get hopefully soon in a much more stable state.</p> Method What it does <code>propertyProxyOf</code> will reference a PropertyProxy <code>syncFunProxyOf</code> will reference a non suspending FunProxy. <code>asyncFunProxyOf</code> will reference a suspending FunProxy. <p>For example they can used as followed:</p> <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SampleRemoteRepositoryMock = kmock()\n\n    someInstance.asyncFunProxyOf(someInstance::fetch).sideEffect = {\n        delay(20)\n        return Any()\n    }\n\n    someInstance.asyncFunProxyOf(someInstance::find).sideEffect = { id -&gt;\n        return if (id.isEmpty()) {\n            throw RuntimeException()\n        } else {\n            Any()\n        }\n    }\n\n    // act\n    val someOtherInstance = SomeClass(someInstance)\n    someOtherInstance.run()\n    ...\n}\n</code></pre> <p>In case you deal with overloaded methods or methods with generics you need to provide those methods a hint, which is composed of the argument types of the Template. Consider following source: <pre><code>interface SampleGenericRemoteRepositoryMock {\n    suspend fun fetch(): Any\n    suspend fun &lt;T&gt; fetch(url: T): Any\n    fun find(id: String): Any\n    fun find(id: String, code: Int): Any\n}\n</code></pre> Which my be address by: <pre><code>@Test\nfun sampleTest() {\n    // arrange\n    val someInstance: SampleGenericRemoteRepositoryMock = kmock()\n\n    someInstance.asyncFunProxyOf&lt;Any&gt;(someInstance::fetch, hint&lt;Any&gt;()).sideEffect = {\n        delay(20)\n        return Any()\n    }\n\n    someInstance.syncFunProxyOf(someInstance::find, hint&lt;String, Int&gt;()).sideEffect = { id -&gt;\n        return if (id.isEmpty()) {\n            throw RuntimeException()\n        } else {\n            Any()\n        }\n    }\n\n    // act\n    val someOtherInstance = SomeClass(someInstance)\n    someOtherInstance.execute()\n    ...\n}\n</code></pre></p> <p>While this may sound amazing these access method have their natural limitations due to Kotlin itself. You will not be able to address Receivers in that way. The signature of the Template maybe too ambiguous in certain cases which makes them unable to resolve the correct Proxy. In those cases you may access Proxies directly. Also you may encounter problems with incremental builds when you use expect/actual Aliases. In those cases take a look at <code>preventResolvingOfAliases</code> in the Gradle Plugin setup.</p>"},{"location":"howto/setup/","title":"Setup","text":""},{"location":"howto/setup/#mandatory-options","title":"Mandatory Options","text":"<p>KMock brings a variety of configuration options. In order to access KMock's extension in Gradle please do the following:</p> <pre><code>    plugins {\n        ...\n\n        id(\"tech.antibytes.kmock.kmock-gradle\")\n    }\n\n    kotlin {\n        ...\n    }\n\n    kmock {\n        rootPackage = \"my.root.package\"\n    }\n</code></pre> <p>The only mandatory option is <code>rootPackage</code>, It expects the root package of your project as a String. This information is need in order to arrange the generate Mocks properly.</p>"},{"location":"howto/setup/#optional-features","title":"Optional Features","text":""},{"location":"howto/setup/#aliases","title":"Aliases","text":"<p>In order to resolve conflicts of mock names KMock allows you make mapping of aliases via <code>aliasNameMapping</code>. It expects a the key of the full qualified name of the Template and as value the Alias as a short name: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    aliasNameMapping = mapOf(\n        \"my.root.package.template.alias.Collision\" to \"Alias\",\n    )\n}\n</code></pre></p>"},{"location":"howto/setup/#build-in-methods","title":"Build-In Methods","text":"<p>KMock will not generate proxies for Build-In methods like hashCode by default in order to avoid unnecessary overhead. However if you need Build-In methods you can tell KMock to generate them via <code>useBuildInProxiesOn</code>. It expects a set of full qualified names of Templates which should have proxies for Build-In methods: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    useBuildInProxiesOn = setOf(\n        \"my.root.package.template.alias.BuildInMethods\"\n    )\n}\n</code></pre></p>"},{"location":"howto/setup/#colliding-method-names","title":"Colliding Method Names","text":"<p>If KMock produces a collision of names for overloaded methods you can resolve it via <code>useTypePrefixFor</code>. It expects a map, while the key must be the full qualified name of causing type and the value is an arbitrary String, which is used as a prefix. <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    useTypePrefixFor = mapOf(\n        \"my.root.package.types.overloaded.Scope.Abc\" to \"Prefix\"\n    )\n}\n</code></pre></p>"},{"location":"howto/setup/#spies","title":"Spies","text":"<p>In order to enable Spies for certain Templates, KMock offers you the <code>spyOn</code>. It expects a set of full qualified names of Templates.</p> <p>Note</p> <p>This will enable Build-In methods for this particular mock as well.</p> <p>Note</p> <p>Spies for Multi-Mocks will triggered if one Interface can be spied on.</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    spyOn = setOf(\n        \"my.root.package.templates.spy.SpyOnMe\"\n    )\n}\n</code></pre>"},{"location":"howto/setup/#spy-on-all","title":"Spy on All","text":"<p>By default KMock will only activate spies via <code>spyOn</code>. If you simply want to enable spying for all Templates spies you can do that via <code>spyAll</code>: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    spyAll = true\n}\n</code></pre></p>"},{"location":"howto/setup/#spies-only","title":"Spies only","text":"<p>If you have no use for Mocks which cannot be spied and you want to spare the compile time of the <code>kmock</code> factories, you may tell this KMock via <code>spiesOnly</code>: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    spiesOnly = true\n}\n</code></pre></p> <p>Note</p> <p><code>spiesOnly</code> will trigger that all Mocks can are spied on like <code>spyAll</code>.</p>"},{"location":"howto/setup/#enable-interface-references","title":"Enable Interface References","text":"<p>In order to be able to utilize interfaces for the <code>kmock</code> or <code>kspy</code> factory you can enable this via <code>allowInterfaces</code>:</p> <p>Tip</p> <p>This will be handy if you use it together with Relaxation.</p> <p>Note</p> <p>This will not work for Multi Interface Mocks.</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    allowInterfaces = true\n}\n</code></pre>"},{"location":"howto/setup/#default-freezing-behaviour","title":"Default Freezing behaviour","text":"<p>By the default all Mocks will not be frozen. If you do not wish that default you can set a new one via <code>freezeOnDefault</code>: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    freezeOnDefault = true\n}\n</code></pre></p>"},{"location":"howto/setup/#disable-factories","title":"Disable Factories","text":"<p>One of the biggest factors in terms of compile time are the generated factories. If you do not mind to wire everything by hand you can disable them via <code>disableFactories</code>:</p> <p>Warning</p> <p>If you do that you are on your own. Also constructors of Mocks are considered as internal. This means do not expect them to have a stable API.</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    disableFactories = true\n}\n</code></pre>"},{"location":"howto/setup/#custom-annotations-for-shared-sources","title":"Custom Annotations for Shared Sources","text":"<p>In order to ease the declaration of Mocks for Shared Sources (e.g. <code>nativeTest</code>)  KMock offers you a hook to define custom annotations via <code>customAnnotationsForMeta</code>. It takes a map. The key must be the full qualified name of your Annotation and the value a (valid) Source Set your Annotations is referring to.</p> <p>Note</p> <p>Before you ask - no, inheritance does not work with annotations.</p> <p>Important</p> <p><code>commonTest</code> as Source Set is not allowed!</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    customAnnotationsForMeta = mapOf(\n        \"my.root.package.annotation.Native\" to \"nativeTest\"\n    )\n}\n</code></pre>"},{"location":"howto/setup/#experimental-features","title":"Experimental Features","text":"<p>The following features are considered as experimental, which means there likely be to changed or removed.</p>"},{"location":"howto/setup/#custommethodnames","title":"CustomMethodNames","text":"<p>Since overloaded method names of Proxies can become very ugly KMock offers you the possibility to rename them via <code>customMethodNames</code>. It expects a map while the key must be the full id of the Proxy you are referring to and the value can be an arbitrary String, which is used as name for the Proxy.</p> <p>Warning</p> <p>This feature will hurt you if the Template is subject to changes, since you have to adjust the mapping each time.</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    customAnnotationsForMeta = mapOf(\n        \"my.root.package.template.renamed.OverloadedMock#_foo\" to \"bar\"\n    )\n}\n</code></pre>"},{"location":"howto/setup/#proxy-access-methods","title":"Proxy Access Methods","text":"<p>In order to enable the experimental ProxyAccessMethods you can switch <code>allowExperimentalProxyAccess</code> to true: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    allowExperimentalProxyAccess = true\n}\n</code></pre></p>"},{"location":"howto/setup/#fine-grained-proxynames","title":"Fine Grained ProxyNames","text":"<p>If you have the need of Proxy names which support the full extend of KMP deferring types you can enable <code>enableFineGrainedNames</code>.</p> <p>Note</p> <p>You will not need that if you work with JVM or Android. This flag will you only help withs native sources and JS.</p> <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    enableFineGrainedNames = true\n}\n</code></pre>"},{"location":"howto/setup/#prevent-resolving-of-aliases","title":"Prevent resolving of Aliases","text":"<p>It may occur that AccessMethods in combination with expect/actual Aliases cause problems with incremental builds. Since it is currently not possible to resolve that automatically you need to declare them by hand: <pre><code>kmock {\n    ...\n    rootPackage = \"my.root.package\"\n    preventResolvingOfAliases = \"my.root.package.subpacke.Alias\"\n}\n</code></pre></p>"},{"location":"howto/terminology/","title":"Terminology","text":"<p>Just to prevent any confusion about terms let's make some quick definitions:</p> <ul> <li>A Proxy relates to a single property (PropertyProxy) or method (FunProxy).</li> <li>A Mock owns multiple Proxies based on an given Interface.</li> <li>Interfaces and their members are used as Templates for Proxies or a Mock.</li> <li>Assertion is strict about order which makes them fail in place and they are absolute/explicit about what they cover.</li> <li>Verification fails after they traversed all available sources, which means they can skip elements.</li> </ul>"}]}